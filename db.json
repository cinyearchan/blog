{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":0,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/fexo/.csscomb.json","hash":"0bff596879c2556634b9a92abe5b1606dc77fd1c","modified":1527515949524},{"_id":"source/.DS_Store","hash":"adacdfc13a39974ecbfa3be85e7b87e11c093e56","modified":1548653738195},{"_id":"themes/fexo/.gitignore","hash":"32223fbe296f8e3026c689bad8f3dea9d0fcbb43","modified":1527515949525},{"_id":"themes/fexo/LICENSE","hash":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1527515949525},{"_id":"themes/fexo/README.md","hash":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1527515949525},{"_id":"themes/fexo/gulpfile.js","hash":"5995b9c4e8e18d1670ad30b2881d49fa17e56415","modified":1527515949526},{"_id":"themes/fexo/_config.yml","hash":"5d59ccfc2987c0448e03f4db98457590dd073cd5","modified":1571208905440},{"_id":"themes/fexo/package.json","hash":"38850a4aa4a01c697bdf2bed87709fe0c8c3fe69","modified":1527515949545},{"_id":"source/_posts/译-Promise-rookie.md","hash":"5644423803fd4a2ba82c0b24d12d688713a6949f","modified":1571210201781},{"_id":"source/_posts/.DS_Store","hash":"4aa952c73d8dd8f363d6e15a716613362660ab76","modified":1530455042495},{"_id":"source/_posts/hello-world.md","hash":"1f678e6d6738302146d6779ba56b38481ef2bb5e","modified":1530455350753},{"_id":"themes/fexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1527515949514},{"_id":"source/_posts/译-Tasks-microtasks-queues-and-schedules.md","hash":"a097f930b46618760fb81dde759b87a7cbf44a38","modified":1571209716689},{"_id":"themes/fexo/.git/config","hash":"a04997723156ad92acd37b6b1249f76028b9aa2d","modified":1527515949517},{"_id":"themes/fexo/.git/index","hash":"430e015d42438af9b11995ada58b1515c329e4d9","modified":1528299069101},{"_id":"source/_posts/译-通过从头实现一个promise来学习promise.md","hash":"6a283c3716ca70d374f15e5a2fa5b2913e1c851f","modified":1528298393713},{"_id":"themes/fexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1527515866765},{"_id":"themes/fexo/.git/packed-refs","hash":"e60e09c9e808d873c989a4576d804f0fe946859c","modified":1527515949511},{"_id":"themes/fexo/languages/default.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1527515949526},{"_id":"themes/fexo/languages/en.yml","hash":"b58364c7dfac61eddd64510f74ca7516da48f0cf","modified":1527515949526},{"_id":"themes/fexo/languages/no.yml","hash":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1527515949526},{"_id":"themes/fexo/languages/zh-CN.yml","hash":"1a6762d52295b0f7586f40c35e713c0fd33c2a2b","modified":1527515949527},{"_id":"themes/fexo/languages/zh-TW.yml","hash":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1527515949527},{"_id":"themes/fexo/package-lock.json","hash":"96cbc6874ae373b7ebd91a8b2a5166e7502514fa","modified":1527515949544},{"_id":"themes/fexo/layout/about.ejs","hash":"f1f06842f3fac2c7dd74811722431c5720e6cf8d","modified":1527515949540},{"_id":"themes/fexo/layout/archive.ejs","hash":"9c22251c328e937c444a9f5d4b324f97a78d324f","modified":1527515949540},{"_id":"themes/fexo/layout/category.ejs","hash":"e8c8209f74ac0c96c29dbdff38d0f43664417342","modified":1527515949540},{"_id":"themes/fexo/layout/index.ejs","hash":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1527515949541},{"_id":"themes/fexo/layout/layout.ejs","hash":"ae485be0f6c0c431245e0cac21dc109c9d0125e8","modified":1527515949541},{"_id":"themes/fexo/layout/link.ejs","hash":"0144bdb1bc5f19763535b79b3302bf85bc0afbff","modified":1527515949541},{"_id":"themes/fexo/layout/post.ejs","hash":"8cf15be489f8f3c11ac0215c16cbce36c854555f","modified":1527515949542},{"_id":"themes/fexo/layout/project.ejs","hash":"ea63f5ffda0d260b5dc2c2e852caddd082e37efa","modified":1527515949542},{"_id":"themes/fexo/layout/search.ejs","hash":"8c6fc59bed1facf14dd6a48bdf8dd44452583f4d","modified":1527515949543},{"_id":"themes/fexo/layout/tag.ejs","hash":"ea8f39f11e6f8750edbf4130abf26168a403b1b4","modified":1527515949543},{"_id":"themes/fexo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1527515866765},{"_id":"themes/fexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1527515866765},{"_id":"themes/fexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1527515866766},{"_id":"themes/fexo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1527515866766},{"_id":"themes/fexo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1527515866765},{"_id":"themes/fexo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1527515866766},{"_id":"themes/fexo/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1527515866765},{"_id":"themes/fexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1527515866764},{"_id":"themes/fexo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1527515866766},{"_id":"themes/fexo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1527515866766},{"_id":"themes/fexo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1527515866766},{"_id":"themes/fexo/.git/logs/HEAD","hash":"5450348cbbe638b6d3920cf2b40fb91c3e5635bc","modified":1527515949515},{"_id":"themes/fexo/layout/_partial/article.ejs","hash":"745f11c21dcf5d01f4aad3818777fc62e45d2f84","modified":1527515949527},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","hash":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1527515949528},{"_id":"themes/fexo/layout/_partial/baidu-push.ejs","hash":"6950255d74efac8811d5b05d0d7a263c3c96486d","modified":1527515949528},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1527515949538},{"_id":"themes/fexo/layout/_partial/head.ejs","hash":"794916e761ea82fb606a2173af68e9bf524f6efb","modified":1527515949539},{"_id":"themes/fexo/layout/_partial/home.ejs","hash":"225b8a001c7aace46f2b39676e968e7cba9a4277","modified":1527515949539},{"_id":"themes/fexo/layout/_partial/load-script.ejs","hash":"4675c917548817118f4a3c5d84acc98d6c61a1d8","modified":1527515949539},{"_id":"themes/fexo/layout/_partial/style.ejs","hash":"d1e80d7cf8b22929f5c6d8590eac38b069ea055d","modified":1527515949539},{"_id":"themes/fexo/source/css/styles.css","hash":"edda7b8f56586203f06fb0fb1cce0f6707a7f234","modified":1527515949546},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1527515949567},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1527515949570},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1527515949571},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1527515949572},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1527515949575},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1527515949576},{"_id":"themes/fexo/source/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1527515949576},{"_id":"themes/fexo/source/fonts/fontello.svg","hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1527515949577},{"_id":"themes/fexo/source/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1527515949578},{"_id":"themes/fexo/source/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1527515949579},{"_id":"themes/fexo/source/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1527515949579},{"_id":"themes/fexo/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1527604831226},{"_id":"themes/fexo/source/js/app.js","hash":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1527515949580},{"_id":"themes/fexo/source/js/bundle.js","hash":"fe2b6d4fbc32c78cd9868fb3b75ad71cf5250f24","modified":1527515949581},{"_id":"themes/fexo/source/js/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1527515949582},{"_id":"themes/fexo/source/js/scroll-spy.js","hash":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1527515949582},{"_id":"themes/fexo/source/js/util.js","hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1527515949583},{"_id":"themes/fexo/source/js/zenscroll.js","hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1527515949583},{"_id":"themes/fexo/source/sass/_animate.scss","hash":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1527515949584},{"_id":"themes/fexo/source/sass/_base.scss","hash":"83f01dbe82e47ce781c6e7eb8a793d95d97e168b","modified":1527515949584},{"_id":"themes/fexo/source/sass/_common.scss","hash":"b1fc97d6d24a92a9a7a9d39be4fe844f5c0f6d44","modified":1527515949585},{"_id":"themes/fexo/source/sass/_fontello.scss","hash":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1527515949585},{"_id":"themes/fexo/source/sass/_fonts.scss","hash":"10e188d379782ae2ee10427544919557036d0137","modified":1527515949585},{"_id":"themes/fexo/source/sass/_highlight-js.scss","hash":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1527515949586},{"_id":"themes/fexo/source/sass/_normalize.scss","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1527515949586},{"_id":"themes/fexo/source/sass/_styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1527515949587},{"_id":"themes/fexo/source/sass/_type.scss","hash":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1527515949587},{"_id":"themes/fexo/source/sass/_variable.scss","hash":"7b05581ef035a88bd1191914ff992103c7812bdf","modified":1527515949588},{"_id":"themes/fexo/source/css/styles.css.map","hash":"dd689c0ab08f3e7923ede7fab9a193c63f253d90","modified":1527515949547},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1527515949574},{"_id":"themes/fexo/source/favicon.ico","hash":"75ee5e32efbfb204e720b03003bee8552b85c43f","modified":1519665544098},{"_id":"themes/fexo/source/sass/pages/_tag.scss","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1527515949596},{"_id":"themes/fexo/.git/refs/heads/master","hash":"834e14ffb65857cd32c5784ce5214e923e1583cc","modified":1527515949515},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","hash":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1527515949528},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","hash":"f18e08e5c8718d5cd6672fc01e25ba457db0a385","modified":1527515949529},{"_id":"themes/fexo/layout/_partial/component/category.ejs","hash":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1527515949529},{"_id":"themes/fexo/layout/_partial/component/changyan.ejs","hash":"a5f39aa1ee2f213324889ba05b5f99eaabf13fc9","modified":1527515949529},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","hash":"8d719cdeeda9d5ab5fbfb5f302fc6edd5bb684b8","modified":1527515949529},{"_id":"themes/fexo/layout/_partial/component/date.ejs","hash":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1527515949530},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","hash":"21de7498d235a52337335108fce7446e1a21ea1c","modified":1527515949530},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","hash":"d5b7f72e008d764f5b5fb13ba6ac7adb8bc0a3e8","modified":1527515949530},{"_id":"themes/fexo/layout/_partial/component/gentie.ejs","hash":"9b78a138fb93a71b481ab25c8dea2e082e5e9d6c","modified":1527515949531},{"_id":"themes/fexo/layout/_partial/component/gitalk.ejs","hash":"37ccc1b114d6fc83c1d47fe7b931d42899f7325f","modified":1527515949531},{"_id":"themes/fexo/layout/_partial/component/gitment.ejs","hash":"cf48268f8b8b0f5a5de6c3d4cf0def9917d5f32d","modified":1527515949531},{"_id":"themes/fexo/layout/_partial/component/hypercomments.ejs","hash":"321339582edb1dd9c4e4ca13108fe494d08494fc","modified":1527515949532},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","hash":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1527515949532},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","hash":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1527515949533},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","hash":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1527515949533},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","hash":"906a6aea44a30e83c4c4e449294c7e4d831c188e","modified":1527515949533},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","hash":"8edceb2fd6c770691bd5cf4a35236c1def8410fe","modified":1527515949533},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","hash":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1527515949534},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","hash":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1527515949534},{"_id":"themes/fexo/layout/_partial/component/prev-net.ejs","hash":"d1cb2e61814bcbd25ccb1628f99b18316e029892","modified":1527515949534},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","hash":"d648ea91ec9dc72bca80d70fbb66f7655bd0ea12","modified":1527515949535},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","hash":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1527515949535},{"_id":"themes/fexo/layout/_partial/component/title.ejs","hash":"e2fcdd904123186648513cfca4c7ad04921d2d57","modified":1527515949536},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","hash":"000be428e925f5595af29eeba37ba6111f7f6511","modified":1527515949536},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","hash":"fcfcccc5b231c4050f1a665b70f7738f9d070541","modified":1527515949537},{"_id":"themes/fexo/layout/_partial/component/uyan.ejs","hash":"afe757c6f45d24640b22d90db6f2799000c6f994","modified":1527515949537},{"_id":"themes/fexo/layout/_partial/component/valine.ejs","hash":"3cbf565937f31001c901e451677e7adbe228bfe6","modified":1527515949538},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1527515949569},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1527515949573},{"_id":"themes/fexo/source/sass/component/_back-top.scss","hash":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1527515949588},{"_id":"themes/fexo/source/sass/component/_category-box.scss","hash":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1527515949588},{"_id":"themes/fexo/source/sass/component/_comments.scss","hash":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1527515949589},{"_id":"themes/fexo/source/sass/component/_donation.scss","hash":"75102b0e6e4ef0a674f04fc8996c8f7ad058143d","modified":1527515949589},{"_id":"themes/fexo/source/sass/component/_hint.scss","hash":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1527515949589},{"_id":"themes/fexo/source/sass/component/_index.scss","hash":"a741a0bfb47d0acdef12cdeb968c104bb002f86d","modified":1527515949589},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","hash":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1527515949590},{"_id":"themes/fexo/source/sass/component/_item-post.scss","hash":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1527515949590},{"_id":"themes/fexo/source/sass/component/_item-title.scss","hash":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1527515949590},{"_id":"themes/fexo/source/sass/component/_item-year.scss","hash":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1527515949591},{"_id":"themes/fexo/source/sass/component/_list-post.scss","hash":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1527515949591},{"_id":"themes/fexo/source/sass/component/_modal.scss","hash":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1527515949591},{"_id":"themes/fexo/source/sass/component/_page-header.scss","hash":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1527515949592},{"_id":"themes/fexo/source/sass/component/_pagination.scss","hash":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1527515949592},{"_id":"themes/fexo/source/sass/component/_prev-net.scss","hash":"1d282b3302e222adbc96a259f69d85afed980bcf","modified":1527515949592},{"_id":"themes/fexo/source/sass/component/_table.scss","hash":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1527515949593},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","hash":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1527515949593},{"_id":"themes/fexo/source/sass/component/_toc.scss","hash":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1527515949593},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","hash":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1527515949593},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","hash":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1527515949594},{"_id":"themes/fexo/source/sass/pages/_about.scss","hash":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1527515949594},{"_id":"themes/fexo/source/sass/pages/_archive.scss","hash":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1527515949594},{"_id":"themes/fexo/source/sass/pages/_category.scss","hash":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1527515949595},{"_id":"themes/fexo/source/sass/pages/_home.scss","hash":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1527515949595},{"_id":"themes/fexo/source/sass/pages/_index.scss","hash":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1527515949595},{"_id":"themes/fexo/source/sass/pages/_link.scss","hash":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1527515949595},{"_id":"themes/fexo/source/sass/pages/_post.scss","hash":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1527515949596},{"_id":"themes/fexo/source/sass/pages/_project.scss","hash":"cab0947fc9d7926a07badaa567803cc7a0968f10","modified":1527515949596},{"_id":"themes/fexo/source/sass/pages/_search.scss","hash":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1527515949596},{"_id":"themes/fexo/.git/objects/pack/pack-8245be3cb971a7b30f41b9b7378255566e8b2d04.idx","hash":"c462f03494e5a2a9a65da68fc8bd423d70a73808","modified":1527515918296},{"_id":"themes/fexo/source/images/avatar.png","hash":"75ee5e32efbfb204e720b03003bee8552b85c43f","modified":1519665544098},{"_id":"themes/fexo/.git/logs/refs/heads/master","hash":"5450348cbbe638b6d3920cf2b40fb91c3e5635bc","modified":1527515949515},{"_id":"themes/fexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1527515949513},{"_id":"themes/fexo/.git/logs/refs/remotes/origin/HEAD","hash":"5450348cbbe638b6d3920cf2b40fb91c3e5635bc","modified":1527515949513},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1527515949551},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1527515949561},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1527515949566},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1527515949558},{"_id":"themes/fexo/.git/objects/pack/pack-8245be3cb971a7b30f41b9b7378255566e8b2d04.pack","hash":"cf4c0e8d72d9e0986020009cb78a1d2a8ed9908f","modified":1527515918295},{"_id":"public/2018/05/28/hello-world/index.html","hash":"535f13ae295a9a83b6dea673f70802601f14a4df","modified":1571210044405},{"_id":"public/index.html","hash":"5ac0aef40f2b66e598d6bd06c63aa6062359d4f1","modified":1571210044455},{"_id":"public/archives/index.html","hash":"3add8c054b1ccb1b35e0dc1ca724e0c7e164d643","modified":1571210044457},{"_id":"public/archives/2018/index.html","hash":"5031339cfe6875db1b07d2cc20551ad9e0d7bdf6","modified":1571210044457},{"_id":"public/archives/2018/05/index.html","hash":"2e4fb2b91a17383035ab203b07bd1b45b4133dbc","modified":1571210044459},{"_id":"public/archives/2018/06/index.html","hash":"4e001f86decd8dcfb7068f23db6d129380123bf1","modified":1571210044459},{"_id":"public/archives/2018/07/index.html","hash":"83881bad5e263b7bb3698fefb20c246bf7c1e058","modified":1571210044459},{"_id":"public/2018/07/01/译-Tasks-microtasks-queues-and-schedules/index.html","hash":"212b4e12c9d75da1b0d2e45eec38a9a0a4f51ece","modified":1571210044459},{"_id":"public/2018/06/06/译-通过从头实现一个promise来学习promise/index.html","hash":"50b37c7737de2ee8c695c9b865011d2cde2c71ac","modified":1571210044459},{"_id":"public/archives/2019/index.html","hash":"13d12f4e70d77cb9c5d79e3272b86084348a9902","modified":1571210044464},{"_id":"public/archives/2019/10/index.html","hash":"99b1e60b1049bbe6c375d2aba066f0e6e0a1acd9","modified":1571210044464},{"_id":"public/2019/10/16/译-Promise-rookie/index.html","hash":"1c7e25b36f94532c23316c0e2c244745e3821ddd","modified":1571210206354},{"_id":"public/fonts/PoiretOne-Regular.eot","hash":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1571210044468},{"_id":"public/fonts/PoiretOne-Regular.ttf","hash":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1571210044468},{"_id":"public/fonts/PoiretOne-Regular.woff","hash":"1cebcedde2c52261591bc322b176638798336a24","modified":1571210044468},{"_id":"public/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1571210044468},{"_id":"public/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1571210044468},{"_id":"public/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1571210044468},{"_id":"public/fonts/fontello.eot","hash":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1571210044469},{"_id":"public/fonts/fontello.svg","hash":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1571210044469},{"_id":"public/fonts/fontello.ttf","hash":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1571210044469},{"_id":"public/fonts/fontello.woff","hash":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1571210044469},{"_id":"public/fonts/fontello.woff2","hash":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1571210044469},{"_id":"public/css/styles.css.map","hash":"dd689c0ab08f3e7923ede7fab9a193c63f253d90","modified":1571210044474},{"_id":"public/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1571210044475},{"_id":"public/js/bundle.js","hash":"fe2b6d4fbc32c78cd9868fb3b75ad71cf5250f24","modified":1571210044484},{"_id":"public/js/app.js","hash":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1571210044484},{"_id":"public/js/scroll-spy.js","hash":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1571210044484},{"_id":"public/js/util.js","hash":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1571210044484},{"_id":"public/js/zenscroll.js","hash":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1571210044484},{"_id":"public/css/styles.css","hash":"edda7b8f56586203f06fb0fb1cce0f6707a7f234","modified":1571210044485},{"_id":"public/js/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1571210044485},{"_id":"public/fonts/PoiretOne-Regular.svg","hash":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1571210044485},{"_id":"public/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1571210044485},{"_id":"public/favicon.ico","hash":"75ee5e32efbfb204e720b03003bee8552b85c43f","modified":1571210044489},{"_id":"public/images/avatar.png","hash":"75ee5e32efbfb204e720b03003bee8552b85c43f","modified":1571210044489},{"_id":"public/fonts/Lobster-Regular.eot","hash":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1571210044495},{"_id":"public/fonts/Lobster-Regular.ttf","hash":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1571210044495},{"_id":"public/fonts/Lobster-Regular.woff","hash":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1571210044496},{"_id":"public/fonts/Lobster-Regular.svg","hash":"be1cab622c673942fb4d11a23c012227938b4792","modified":1571210044501}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"清理老博客，hello world :)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\n清理老博客，hello world :)\n","slug":"hello-world","published":1,"date":"2018-05-28T13:42:01.221Z","updated":"2018-07-01T14:29:10.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sxw4xi0000gn4mg104pi8i","content":"<p>清理老博客，hello world :)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>清理老博客，hello world :)</p>\n"},{"title":"[译]Promise rookie","date":"2019-10-16T07:12:57.000Z","_content":"\n\nJS程序员们，是时候承认了：我们的 promise 有问题\n\n等等，我不是说 promise 本身有问题，基于 [A+ 规范](https://promisesaplus.com/) 编写的 Promise 自然是无懈可击\n\n我说的这个问题在过去的一年里反复出现，我见到了无数的程序员栽在了 PouchDB API 和其他深度基于 promise 的 API 上：\n\n我们中的绝大多数对 promise 的使用只停留在一知半解的层面\n\n不信？不妨看看我在推特上 po 出的 [题目](https://twitter.com/nolanlawson/status/578948854411878400)：\n\n#### 以下四个 `promise` 有什么区别\n\n```javascript\ndoSomething().then(function() {\n\treturn doSomethingElse();\n});\n\ndoSomething().then(function() {\n\tdoSomethingElse();\n});\n\ndoSomething().then(doSomethingElse());\n\ndoSomething().then(doSomethingElse);\n```\n\n答案在本文的末尾\n\n\n\n### 为什么要使用 promise\n\n如果你读过 promise 相关文章，你会发现有一个名词会被经常提到——[the pyramid of doom 末日金字塔](https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf) ——一些可怕的回调代码，层层嵌套，稳定地向屏幕右侧延伸\n\nPromise 的出现确实解决了这个问题，但它的作用不仅限于减少代码缩进！正如 [Redemption from Callback Hell](http://youtu.be/hf1T_AONQJU) 中解释的，回调带来的真正问题是它剥夺了我们使用 `return` 和 `throw` 的权利，与此同时，我们的程序的整个流程都是基于副作用：一个函数顺带调用另一个函数\n\n实际上，回调“作的恶”不止于此：它让我们与栈隔绝（栈：在编程语言中通常用来保证程序顺利运行的东西）！脱离栈写代码就像是开着一辆没有刹车的车一样危险——你根本不知道自己的处境有多危险，知道危险来临，你需要它时才发现它不在!\n\nPromise 的重点在于，在我们写异步代码时，让我们重拾丢失的语言规范：`return`、`throw` 以及栈。\n\n但你必须知道如何正确使用 promise 才能充分享受它带来的好处，否则只会是驱虎吞狼、后患无穷\n\n### 初阶错误\n\n#### 新手错误：promise的末日金字塔\n\n```javascript\nremotedb.allDocs({\n\tinclude_docs: true,\n\tattachments: true\n}).then(function(result) {\n\tvar docs = result.rows;\n\tdocs.forEach(function(element) {\n\t\tlocaldb.put(element.doc).then(function(response) {\n\t\t\talert(\"Pulled doc with id \" + element.doc._id + \" and added to local db.\");\n\t\t}).catch(function(err) {\n\t\t\tif (err.name == 'conflict') {\n\t\t\t\tlocaldb.get(element.doc._id).then(function(resp) {\n\t\t\t\t\tlocaldb.remove(resp._id, resp._rev).then(function(resp) {\n\t\t\t\t\t\t// ... 诸如此类\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\t})\n})\n```\n\n改进版：\n```javascript\nremotedb.allDocs(...).then(function(resultOfAllDocs) {\n\treturn localdb.put(...);\n}).then(function(resultOfPut) {\n\treturn localdb.get(...);\n}).then(function(resultOfGet) {\n\treturn localdb.put(...);\n}).catch(function(err) {\n\tconsole.log(err);\n})\n```\n这被称为 `composing promises` 即“合成promises”，这是 `promises` 所提供的强大魔力之一。每一个方法只会在前一个 `promise` 转变为 `resolved` 状态时被调用，并且可以获取前一个 `promise` 的结果\n\n#### 新手错误2：`forEach()/循环` 与 `promise` 如何兼得\n```javascript\n// 我想通过 remove() 处理所有文档\ndb.allDocs({include_docs: true}).then(function(result) {\n\tresult.rows.forEach(function(rows) {\n\t\tdb.remove(row.doc);\n\t});\n}).then(function() {\n\t// 我认为所有文档都被移除了 ha?\n});\n```\n上述代码有什么问题？问题在于，第一个 function 会返回 undefined，意味着第二个 function 不会等待所有文档都执行 db.remove()。实际上，它根本什么都不会等，任意数目的文档被移除时，第二个方法都会执行。\n\n解决的方法是，应该用 `Promise.all()` 来替代 `forEach()`/`for`/`while` 处理异步循环\n```javascript\ndb.allDocs({include_docs: true}).then(function(resp) {\n\treturn Promise.all(result.rows.map(function(row) {\n\t\treturn db.remove(row.doc);\n\t}));\n}).then(function(arrayOfResults) {\n\t// 此时，所有文档才真正被移除\n});\n```\n这到底发生了什么？简单来说，`Promise.all()` 以一个包含多个 promise 的数组作为输入，返回另一个 promise 作为输出，只有当输入数组中的所有 promise 的状态都转变为 `resolved`，该输出的 promise 状态才会变成 `resolved`，相当于异步的for循环\n\n`Promise.all()` 也会向随后的处理函数传递一个包含所有结果的数组，这是非常有用的，例如，试图通过 `get()` 从 PouchDB 中获取多个数据。如果输入数组中包含的 promise，有任意一个状态转变为 `rejected`，该 `all()`的 promise 都会变为 `rejected`\n\n#### 新手错误3：忘记加上 `.catch()`\n\n这是另一个常见的错误。简单的认为他们写的promise绝不会抛出错误，很多开发者都会忘记在 promise 链的末尾加上 `.catch()`。一旦如此，promise 中任何被抛出的错误都会被掩盖，甚至无法再 console 中展现，无疑会提高 debug 的难度\n\n为避免上述情况的发生，我建议在每一个promise链的末尾都加上 `.catch()`：\n\n```javascript\nsomePromise().then(function() {\n  return anotherPromise();\n}).then(function() {\n  return yetAnotherPromise();\n}).catch(console.log.bind(console)); // <-- this is badass\n```\n\n\n\n#### 新手错误4：使用 `deferred`\n\n我总是能看到这类[错误](http://gonehybrid.com/how-to-use-pouchdb-sqlite-for-local-storage-in-your-ionic-app/)，以至于我现在都不愿意重复这个单词\n\n简而言之，promise有一段漫长且曲折的历史，JS社区花费了大量的时间来纠正期间的错误。在promise发展的早期，jQuery 和 Angular 都通过 \"deferred\" 来实现各自的 promise，而现如今都被 ES6 的 promise 所取代，例如Q、when、RSVP、Bluebird、Lie等库都实现了符合 promise/A+ 规范的 promise\n\n如何避免使用 deferred 呢？\n\n首先，绝大多数 promise 库都会为你引入第三方库实现的 promise 的方法。例如，Angular 中的 `$q` 模块允许你通过 `$q.when()` 来包裹不符合 `$q` 规范的 promise。所以，Angular 使用者可以这样包裹 PouchDB promises：\n\n```javascript\n$q.when(db.put(doc)).then(/* ... */); // <-- 这就是你迫切需要的\n```\n\n另一个方法是使用[revealing constructor pattern](https://blog.domenic.me/the-revealing-constructor-pattern/)来包裹非 promise 的API。例如，封装基于回调的API，比如说 Nodejs 中的 `fs.readFile()`，可以这样做：\n\n```javascript\nnew Promise(function(resolve, reject) {\n  fs.readFile('myfile.txt', function(err, file) {\n    if (err) {\n      return reject(err);\n    }\n    resolve(file);\n  });\n}).then(/* ... */)\n```\n\n\n\n#### 新手错误5：使用副作用而不是返回\n\n以下代码有什么问题？\n\n```javascript\nsomePromise().then(function() {\n  someOtherPromise();\n}).then(function() {\n  // 我希望 someOtherPromise() 已经是 resolved 状态了\n  // 事实却告诉我，它不是\n});\n```\n\n是时候来详细了解 promise 的各个要点了\n\n正如我之前所说，promise 的魔力在于它回馈我们之前的 `return` 和 `throw`。实际中是如何体现的呢？\n\n每一个 promise 都会为你提供一个 `then()` 方法（或者 `catch()`方法，`then(null, ...)` 的语法糖）。让我们进入 `then()` 函数的内部：\n\n```javascript\nsomePromise().then(function() {\n  // 现在是 then() 函数的内部\n})\n```\n\n我们在 `then()` 函数内部可以做什么？有三件事是可以做的：\n\n1. `return` 另一个 promise\n\n2. `return` 一个同步的值（或 `undefined`）\n\n3. `throw` 一个同步的 error\n\n   \n  \n\n一旦你掌握其中的诀窍，你就解开了 promise 的魔术。让我们逐点分析：\n\n1. 返回另一个 promise\n\n   这个模式在 promise 相关文章中很常见，就像上面提到的“合成promise”：\n\n   ```javascript\n   getUserByName('nolan').then(function(user) {\n     return getUserAccountById(user.id);\n   }).then(function(userAccount) {\n     // I got a user account!\n   });\n   ```\n\n   注意此处，我返回了第二个 promise ——返回 `return` 是关键，如果没有 `return` ，`getUserAccountById()` 就只会产生副作用，第二个 then 的处理函数就只能接收到 `undefined` 而不是 `userAccount`\n\n2. 返回一个同步的值（或 undefined）\n\n   返回 `undefined` 通常来说是一个错误，但返回一个同步的值，却是一种将同步代码转换为 promise 风格代码的很酷的方式。例如，我们有一份用户的缓存数据，我们可以做什么呢：\n\n   ```javascript\n   getUserByName('nolan').then(function(user) {\n     if (inMemoryCache[user.id]) {\n       return inMemoryCache[user.id]; // returning a synchronous value!\n     }\n     return getUserAccountById(user.id); // returning a promise!\n   }).then(function(userAccount) {\n     // I got a user account!\n   });\n   ```\n\n   这不是很酷么？第二个函数根本不用关心 `userAccount` 是同步获取的还是异步获取的，第一个函数也可以随意返回同步的值或者异步的值。\n\n   不幸的是，有个麻烦的事实摆在眼前：无返回值的函数，严格来说，都会默认返回 `undefined` ，意味着当你打算返回某些东西的时候，很容易在不经意间就产生副作用\n\n   出于这个原因，我的个人习惯是，总是在 `.then()` 函数内加上 `return` 或者 `throw` sth，我建议你也这样做\n\n3. 抛出同步的异常\n\n   说到 `throw` ，这是 promise 可以变得更加令人敬畏之处。比如说我们希望能够抛出一个同步的异常以防用户登出：\n\n   ```javascript\n   getUserByName('nolan').then(function(user) {\n     if (user.isLoggedOut()) {\n       throw new Error('user logged out!'); // throwing a synchronous error!\n     }\n     if (inMemoryCache[user.id]) {\n       return inMemoryCache[user.id]; // returning a synchronous value!\n     }\n     return getUserAccountById(user.id); // returning a promise!\n   }).then(function(userAccount) {\n     // I got a user account!\n   }).catch(function(err) {\n     // Boom, I got an error!\n   });\n   ```\n\n   上述代码中，如果用户登出，`catch()` 会捕获到一个同步的异常，并且如果任意一个 promise 变为 rejected 状态， `catch()` 会捕获到一个异步的异常。同样，`catch()` 函数无需关系捕获的异常是同步的还是异步的。\n\n   这在开发过程中确定代码异常极其有效！举个例子，在 `then()` 函数内部任意一处，我们执行 `JSON.parse()` 操作，如果是 JSON 是无效的，则会抛出一个同步的异常。在回调中，该异常会被掩盖；但在 promise 中，我们可以在 `catch()` 中轻松处理捕获到的异常。\n\n\n\n### 进阶错误\n\n既然你已经学到了可以让 promise 变得简单的单一技巧，不妨来看看一些边角案例，当然，编程总是会遇到边角案例\n\n之所以说这些案例是进阶的，是因为我发现那些已经相当擅长 promise 的程序员才犯这些错。如果想弄清楚文章开头提到的那个问题，我们就有必要研究清楚这些案例\n\n\n\n#### 进阶错误1：不知道 `Promise.resolve()`\n\n正如我在上面提到的，promise 非常擅长将同步代码封装为异步代码。然而，如果下面这段代码你敲得多了的话：\n\n```javascript\nnew Promise(function(resolve, reject) {\n  resolve(someSynchronousValue);\n}).then(/* ... */);\n```\n\n你可以用 `Promise.resolve()` 来更简洁的表明这一点：\n\n```javascript\nPromise.resolve(someSynchronousValue).then(/* ... */);\n```\n\n这在捕获任何同步的异常上也极其有效，正因如此，我已经养成了几乎所有 promise 返回API方法的习惯，如下所示：\n\n```javascript\nfunction somePromiseAPI() {\n  return Promise.resolve().then(function() {\n    doSomethingThatMayThrow();\n    return 'foo';\n  }).then(/* ... */);\n}\n```\n\n记住一点：任何可能同步抛出的代码，都可以在某处找到几乎不可能调试的隐藏的异常。如果你用 `Promise.solve()` 包裹一切同步代码，则你总是可以在之后通过 `catch()` 函数捕获异常\n\n相似的，你可以用 `Promise.reject()` 来返回一个状态立刻变为 `rejected` 的 promise 实例：\n\n```javascript\nPromise.reject(new Error('some awful error'));\n```\n\n\n\n#### 进阶错误2：`then(resolveHandler).catch(rejectHandler)` 并不全等于 `then(resolveHandler, rejectHandler)`\n\n上面提到的 `catch()` 是语法糖，因此如下两个代码片段是等价的：\n\n```javascript\nsomePromise().catch(function(err) {\n  // handle error\n});\n\nsomePromise().then(null, function(err) {\n  // handle error\n});\n```\n\n然而，下面两段代码却不是等价的：\n\n```javascript\nsomePromise().then(function() {\n  return someOtherPromise();\n}).catch(function(err) {\n  // handle error\n});\n\nsomePromise().then(function() {\n  return someOtherPromise();\n}, function(err) {\n  // handle error\n});\n```\n\n如果你还在疑惑为何不等价，不妨设想当第一个函数抛出异常时：\n\n```javascript\nsomePromise().then(function() {\n  throw new Error('oh noes');\n}).catch(function(err) {\n  // I caught your error! :)\n});\n\nsomePromise().then(function() {\n  throw new Error('oh noes');\n}, function(err) {\n  // I didn't catch your error! :(\n});\n```\n\n事实证明，当你使用 `then(resolveHandler, rejectHandler)` 格式时，如果 `resolveHandler` 自身抛出了异常，`rejectHandler` 是自然无法捕获到的\n\n为此，我自己的习惯是：从不使用 `then()` 函数的第二个参数，而是使用 `catch()`。例外则是，当我在写异步的[Mocha](http://mochajs.org/) 测试用例时，我会使用第二个参数来确保异常能够被抛出：\n\n```javascript\nit('should throw an error', function() {\n  return doSomethingThatThrows().then(function() {\n    throw new Error('I expected an error!');\n  }, function(err) {\n    should.exist(err);\n  });\n});\n```\n\n说到测试，在测试 promise API时，[Mocha](http://mochajs.org/) 和 [Chai](http://chaijs.com/) 是绝妙的组合。[pouchdb-plugin-seed](https://github.com/pouchdb/plugin-seed)项目中有一些简单的 [测试用例](https://github.com/pouchdb/plugin-seed/blob/master/test/test.js) 可以拿来练手\n\n\n\n#### 进阶错误3：promises VS promise factories\n\n或许你想按顺序一个一个的处理一组 promise，处理的方式近似于 `Promise.all()` ，但其中的 promise 却不是并发执行的\n\n你可能简单的认为理想的代码是这样的：\n\n```javascript\nfunction executeSequentially(promises) {\n  var result = Promise.resolve();\n  promise.forEach(function(promise) {\n    result = result.then(promise);\n  });\n  return result;\n}\n```\n\n实际上，上述代码无法达到你预期的效果，传递给 `executeSequentially()` 的多个 promise 仍然会并发执行\n\n发生这种情况的原因是你根本不想操作 promise 的数组，根据 promise 规范，一旦创建了 promise，它就会开始执行，你真正想要的是 promise factories 的数组\n\n```javascript\nfunction executeSequentially(promiseFactories) {\n  var result = Promise.resolve();\n  promiseFactories.forEach(function(promiseFactory) {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n```\n\n我知道你在想什么：“这个 Java 程序员到底是谁，为什么他在谈论 factories 呢？”promise factories 很简单，只是一个会返回一个 promise 实例的函数而已:\n\n```javascript\nfunction myPromiseFactory() {\n  return somethingThatCreatesAPromise();\n}\n```\n\n这管用么？管用！promise factory 只有被调用时才会生成 promise，它运行的方式类似于 `then` 函数——实际上，它们就是一回事\n\n观察上述的 `executeSequentially()` 函数，然后想象 `myPromiseFactory` 被替换进 `result.then(...)` 内部，之后豁然开朗，这时你才刚接触到 promise 的启蒙\n\n\n\n#### 进阶错误4：如果我想要两个 promise 实例的结果呢\n\n通常，一个 promise 实例将取决于另一个 promise 实例，但如果想要获取这两个 promise 实例的输出呢？比如说：\n\n```javascript\ngetUserByName('nolan').then(function(user) {\n  return getUserAccountById(user.id);\n}).then(function(userAccount) {\n  // 槽糕，我也需要获取 user 对象啊！\n});\n```\n\n既要当个优秀的JS程序员，又要避免“爆炸金字塔”的出现，我们或许应该将 `user` 对象存储在更高一级作用域的变量中：\n\n```javascript\nvar user;\ngetUserByName('nolan').then(function(result) {\n  user = result;\n  return getUserAccountById(user.id);\n}).then(function(userAccount) {\n  // 好了，user 和 userAccount 都可以获取到了\n});\n```\n\n这办法能用，但只是凑合。我的建议是：放开先前的偏见，拥抱金字塔：\n\n```javascript\ngetUserByName('nolan').then(function(user) {\n  return getUserAccountById(user.id).then(function(userAccount) {\n  // 你看，我也可以获取 user 和 userAccount \n  });\n});\n```\n\n至少，暂时的“拥抱金字塔”:)\n\n如果代码缩进变成了一个问题，那你可以做JS程序员“自古以来”一直在做的事——将函数提取到一个命名函数：\n\n```javascript\nfunction onGetUserAndUserAccount(user, userAccount) {\n  return doSomething(user, userAccount);\n}\n\nfunction onGetUser(user) {\n  return getUserAccountById(user.id).then(function(userAccount) {\n    return onGetUserAndUserAccount(user, userAccount);\n  });\n}\n\ngetUserByName('onlan')\n\t.then(onGetUser)\n\t.then(function() {\n  // 运行到这里时，doSomething() 已经执行完毕，我们的缩进归零了\n});\n```\n\n当你的 promise 代码越来越复杂时，你会发现你会将越来越多的函数提取到命名函数中，代码也会变得更加美观：\n\n```javascript\nputYourRightFootIn()\n\t.then(putYourRightFootOut)\n\t.then(putYourRightFootIn)\n\t.then(shakeItAllAbout);\n```\n\n这就是 promise 出现的意义！\n\n\n\n#### 进阶错误5：promise fall through 通过\n\n这是我在上面介绍 promise 时提到的错误，极其深奥的案例，或许永远都不会出现在你的代码里，但它着实让我吓了一跳\n\n看到如下代码你有什么想法么：\n\n```javascript\nPromise.resolve('foo').then(Promise.resolve('bar')).then(function(result) {\n  console.log(result);\n});\n```\n\n你可能觉得会打印 `bar`，但结果却是 `foo`\n\n原因在于，当你向 `then()` 传递一个非函数（例如 promise 实例）时，它实际上会将其看作 `then(null)` ，这会导致前一个 promise 的结果通过。你不妨试试：\n\n```javascript\nPromise.resolve('foo').then(null).then(function(result) {\n  console.log(result);\n});\n```\n\n就算中间加上无数的 `then(null)`，打印的结果仍然是 `foo`\n\n这实际上回到了之前关于 promise VS promise factories 的讨论。简单地说，你可以直接向 `then()` 方法中传入一个 promise 实例，但它却不会依照你希望的那样运行。`then()` 期望获取一个函数，所以大部分情况你的意思应该是：\n\n```javascript\nPromise.resolve('foo').then(function() {\n  return Promise.resolve('bar');\n}).then(function(result) {\n  console.log(result); // 结果是 bar，正如我们期望的\n});\n```\n\n所以记住一点：给 `then()` 传入的只能是函数（不要传别的什么）！\n\n\n\n\n\n### 答疑\n\n##### 题目一\n\n```javascript\ndoSomething().then(function() {\n  return doSomethingElse();\n}).then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|-----------------|\n                  doSomethingElse(undefined)\n                  |------------------|\n                                     finalHandler(resultOfDoSomethingElse)\n                                     |------------------|\n```\n\n\n\n##### 题目二\n\n```javascript\ndoSomething().then(function() {\n  doSomethingElse();\n}).then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|------------------|\n                   doSomethingElse(undefined)\n                   |------------------|\n                   finalHandler(undefined)\n                   |------------------|\n```\n\n\n\n##### 题目三\n\n```javascript\ndoSomething().then(doSomethingElse())\n\t.then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|------------------|\ndoSomethingElse(undefined)\n|---------------------------------|\n                   finalHandler(resultOfDoSomething)\n                   |------------------|\n```\n\n\n\n##### 题目四\n\n```javascript\ndoSomething().then(doSomethingElse)\n\t.then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|-----------------|\n                  doSomethingElse(resultOfDoSomething)\n                  |-----------------|\n                                    finalHandler(resultOfDoSomethingElse)\n                                    |-----------------|\n```\n\n\n\n如果还是不太明白这些答案，我建议你重新再把这篇文章看一遍，或者自己定义 `doSomething()` 和 `doSomethingElse()` 这两个方法，放到浏览器里试试\n\n\n\n> 说明：这些给出的例子，我假定 `doSomething()` 和 `doSomethingElse()` 都返回 promise，并且这些 promise 表示在 JavaScript 事件循环之外完成的事（例如 IndexedDB、network、setTimeout），这就是为什么在合适的情况下，它们显示成并发，[演示](http://jsbin.com/tuqukakawo/1/edit?js,console,output)\n\n\n\npromise 的更多进阶用法—— [promise protips chear sheet](https://gist.github.com/nolanlawson/6ce81186421d2fa109a4)\n\n\n\n#### 关于 promise 的最后几句话\n\nPromise 是伟大的，如果你仍然在使用回调（嵌套），我强烈建议你讲代码转换为 promise 风格，你的代码将变得更加紧凑、优雅、更具可读性\n\n不信？你看这个例子：[a refactor of PouchDB's map/reduce module](https://t.co/hRyc6ENYGC) 其中用 promise 取代回调，结果是：290个插入操作，555个删除操作\n\n顺带提一句，那个写出恶心的回调嵌套代码的人，其实是我自己，所以这也算是我在 promise 原初魔力的第一课，同时感谢其他 PouchDB 的贡献者一路对我的指导\n\n话虽如此，promise 并非完美，但就像是瘦死的骆驼比马大，promise 仍旧要好过回调，因此就目前而言，其中一个要比另一个更接近“完美”，但是如果你有机会选择更好的，那就要尽力避免它们俩\n\n虽然优于回调，promise 仍然难以理解且极易出错，正因如此我才写下这篇文章讲明其中事实。新手和专家都会经常混淆这些概念，真的，这不是他们的错，问题在于 promise ——虽然近似于我们在同步代码中使用的模式，看起来是个不错的替代品，但却不是百分之百相同\n\n实际上，你不应该学习一堆神秘的规则和新的 API 来做这些事，在同步的世界里，你可以完全使用你熟悉的模式，如 `return`、`catch`、`throw`和 `for` 循环。你的脑子里不应该始终有两套系统并行！\n\n\n\n#### Awaiting async/await\n\n这是我另一篇文章 [Taming the asynchronous beast with ES7](http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html) 中讨论的要点，其中我研究了 ES7 的关键字 `async`/`await`，以及它们如何将 promise 深层次的融合到 JS 这门语言中。相比于写伪同步代码（其中提供的 `catch()` 方法看似与 `catch` 一致，实则不然），ES7 允许我们使用真正的 `try`/`catch`/`return` 关键字，正如我们在 CS 101 里学到的那样\n\n\n\n就 JS 这门语言来说，这是一个巨大的福音。因为最终，只要工具不在我们犯错时及时提示，这些 promise 反模式就总是会不经意出现\n\n\n\n以 JS 的历史为例，我认为 [JSLint](http://jslint.com/) 和 [JSHint](http://jshint.com/) 对 JS 社区做出的贡献要比 [JS 语言精粹](http://amzn.com/0596517742) 要多，即使它们有效的包含相同的信息。这就像是“明确指出你的代码中何处出错了”和“通过阅读一本书来试图搞清楚别人的代码是怎么出错的”的区别\n\n\n\nES7 的 `async`/`await` 的美在于，在大多数情况下，代码中的错误会将自己显示为语法、编译器错误，而不是运行时的微妙的错误。不过，在那之前，熟悉并掌握 promise，以及如何在 ES5 和 ES6 中正确使用是一件好事\n\n但我却意识到一点，就像是《JS 语言精粹》这本书一样，这篇文章所能提供的影响是有限的。但当你看到他们犯同样的错误时，你完全有能力指出其中的错误，因为我们中有太多的人需要承认一点：我还并没有百分之百掌握 promise ！\n\n\n\n> 更新：需要指出的一点是：Bluebird 3.0 将会提供告警信息以避免我在本文中提到的许多错误。所以，在 ES7 完全推出之前，Bluebird 会是另一个非常不错的选择\n\n\n\n[原文地址](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)\n\n","source":"_posts/译-Promise-rookie.md","raw":"---\ntitle: '[译]Promise rookie'\ndate: 2019-10-16 15:12:57\ntags:\n---\n\n\nJS程序员们，是时候承认了：我们的 promise 有问题\n\n等等，我不是说 promise 本身有问题，基于 [A+ 规范](https://promisesaplus.com/) 编写的 Promise 自然是无懈可击\n\n我说的这个问题在过去的一年里反复出现，我见到了无数的程序员栽在了 PouchDB API 和其他深度基于 promise 的 API 上：\n\n我们中的绝大多数对 promise 的使用只停留在一知半解的层面\n\n不信？不妨看看我在推特上 po 出的 [题目](https://twitter.com/nolanlawson/status/578948854411878400)：\n\n#### 以下四个 `promise` 有什么区别\n\n```javascript\ndoSomething().then(function() {\n\treturn doSomethingElse();\n});\n\ndoSomething().then(function() {\n\tdoSomethingElse();\n});\n\ndoSomething().then(doSomethingElse());\n\ndoSomething().then(doSomethingElse);\n```\n\n答案在本文的末尾\n\n\n\n### 为什么要使用 promise\n\n如果你读过 promise 相关文章，你会发现有一个名词会被经常提到——[the pyramid of doom 末日金字塔](https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf) ——一些可怕的回调代码，层层嵌套，稳定地向屏幕右侧延伸\n\nPromise 的出现确实解决了这个问题，但它的作用不仅限于减少代码缩进！正如 [Redemption from Callback Hell](http://youtu.be/hf1T_AONQJU) 中解释的，回调带来的真正问题是它剥夺了我们使用 `return` 和 `throw` 的权利，与此同时，我们的程序的整个流程都是基于副作用：一个函数顺带调用另一个函数\n\n实际上，回调“作的恶”不止于此：它让我们与栈隔绝（栈：在编程语言中通常用来保证程序顺利运行的东西）！脱离栈写代码就像是开着一辆没有刹车的车一样危险——你根本不知道自己的处境有多危险，知道危险来临，你需要它时才发现它不在!\n\nPromise 的重点在于，在我们写异步代码时，让我们重拾丢失的语言规范：`return`、`throw` 以及栈。\n\n但你必须知道如何正确使用 promise 才能充分享受它带来的好处，否则只会是驱虎吞狼、后患无穷\n\n### 初阶错误\n\n#### 新手错误：promise的末日金字塔\n\n```javascript\nremotedb.allDocs({\n\tinclude_docs: true,\n\tattachments: true\n}).then(function(result) {\n\tvar docs = result.rows;\n\tdocs.forEach(function(element) {\n\t\tlocaldb.put(element.doc).then(function(response) {\n\t\t\talert(\"Pulled doc with id \" + element.doc._id + \" and added to local db.\");\n\t\t}).catch(function(err) {\n\t\t\tif (err.name == 'conflict') {\n\t\t\t\tlocaldb.get(element.doc._id).then(function(resp) {\n\t\t\t\t\tlocaldb.remove(resp._id, resp._rev).then(function(resp) {\n\t\t\t\t\t\t// ... 诸如此类\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\t})\n})\n```\n\n改进版：\n```javascript\nremotedb.allDocs(...).then(function(resultOfAllDocs) {\n\treturn localdb.put(...);\n}).then(function(resultOfPut) {\n\treturn localdb.get(...);\n}).then(function(resultOfGet) {\n\treturn localdb.put(...);\n}).catch(function(err) {\n\tconsole.log(err);\n})\n```\n这被称为 `composing promises` 即“合成promises”，这是 `promises` 所提供的强大魔力之一。每一个方法只会在前一个 `promise` 转变为 `resolved` 状态时被调用，并且可以获取前一个 `promise` 的结果\n\n#### 新手错误2：`forEach()/循环` 与 `promise` 如何兼得\n```javascript\n// 我想通过 remove() 处理所有文档\ndb.allDocs({include_docs: true}).then(function(result) {\n\tresult.rows.forEach(function(rows) {\n\t\tdb.remove(row.doc);\n\t});\n}).then(function() {\n\t// 我认为所有文档都被移除了 ha?\n});\n```\n上述代码有什么问题？问题在于，第一个 function 会返回 undefined，意味着第二个 function 不会等待所有文档都执行 db.remove()。实际上，它根本什么都不会等，任意数目的文档被移除时，第二个方法都会执行。\n\n解决的方法是，应该用 `Promise.all()` 来替代 `forEach()`/`for`/`while` 处理异步循环\n```javascript\ndb.allDocs({include_docs: true}).then(function(resp) {\n\treturn Promise.all(result.rows.map(function(row) {\n\t\treturn db.remove(row.doc);\n\t}));\n}).then(function(arrayOfResults) {\n\t// 此时，所有文档才真正被移除\n});\n```\n这到底发生了什么？简单来说，`Promise.all()` 以一个包含多个 promise 的数组作为输入，返回另一个 promise 作为输出，只有当输入数组中的所有 promise 的状态都转变为 `resolved`，该输出的 promise 状态才会变成 `resolved`，相当于异步的for循环\n\n`Promise.all()` 也会向随后的处理函数传递一个包含所有结果的数组，这是非常有用的，例如，试图通过 `get()` 从 PouchDB 中获取多个数据。如果输入数组中包含的 promise，有任意一个状态转变为 `rejected`，该 `all()`的 promise 都会变为 `rejected`\n\n#### 新手错误3：忘记加上 `.catch()`\n\n这是另一个常见的错误。简单的认为他们写的promise绝不会抛出错误，很多开发者都会忘记在 promise 链的末尾加上 `.catch()`。一旦如此，promise 中任何被抛出的错误都会被掩盖，甚至无法再 console 中展现，无疑会提高 debug 的难度\n\n为避免上述情况的发生，我建议在每一个promise链的末尾都加上 `.catch()`：\n\n```javascript\nsomePromise().then(function() {\n  return anotherPromise();\n}).then(function() {\n  return yetAnotherPromise();\n}).catch(console.log.bind(console)); // <-- this is badass\n```\n\n\n\n#### 新手错误4：使用 `deferred`\n\n我总是能看到这类[错误](http://gonehybrid.com/how-to-use-pouchdb-sqlite-for-local-storage-in-your-ionic-app/)，以至于我现在都不愿意重复这个单词\n\n简而言之，promise有一段漫长且曲折的历史，JS社区花费了大量的时间来纠正期间的错误。在promise发展的早期，jQuery 和 Angular 都通过 \"deferred\" 来实现各自的 promise，而现如今都被 ES6 的 promise 所取代，例如Q、when、RSVP、Bluebird、Lie等库都实现了符合 promise/A+ 规范的 promise\n\n如何避免使用 deferred 呢？\n\n首先，绝大多数 promise 库都会为你引入第三方库实现的 promise 的方法。例如，Angular 中的 `$q` 模块允许你通过 `$q.when()` 来包裹不符合 `$q` 规范的 promise。所以，Angular 使用者可以这样包裹 PouchDB promises：\n\n```javascript\n$q.when(db.put(doc)).then(/* ... */); // <-- 这就是你迫切需要的\n```\n\n另一个方法是使用[revealing constructor pattern](https://blog.domenic.me/the-revealing-constructor-pattern/)来包裹非 promise 的API。例如，封装基于回调的API，比如说 Nodejs 中的 `fs.readFile()`，可以这样做：\n\n```javascript\nnew Promise(function(resolve, reject) {\n  fs.readFile('myfile.txt', function(err, file) {\n    if (err) {\n      return reject(err);\n    }\n    resolve(file);\n  });\n}).then(/* ... */)\n```\n\n\n\n#### 新手错误5：使用副作用而不是返回\n\n以下代码有什么问题？\n\n```javascript\nsomePromise().then(function() {\n  someOtherPromise();\n}).then(function() {\n  // 我希望 someOtherPromise() 已经是 resolved 状态了\n  // 事实却告诉我，它不是\n});\n```\n\n是时候来详细了解 promise 的各个要点了\n\n正如我之前所说，promise 的魔力在于它回馈我们之前的 `return` 和 `throw`。实际中是如何体现的呢？\n\n每一个 promise 都会为你提供一个 `then()` 方法（或者 `catch()`方法，`then(null, ...)` 的语法糖）。让我们进入 `then()` 函数的内部：\n\n```javascript\nsomePromise().then(function() {\n  // 现在是 then() 函数的内部\n})\n```\n\n我们在 `then()` 函数内部可以做什么？有三件事是可以做的：\n\n1. `return` 另一个 promise\n\n2. `return` 一个同步的值（或 `undefined`）\n\n3. `throw` 一个同步的 error\n\n   \n  \n\n一旦你掌握其中的诀窍，你就解开了 promise 的魔术。让我们逐点分析：\n\n1. 返回另一个 promise\n\n   这个模式在 promise 相关文章中很常见，就像上面提到的“合成promise”：\n\n   ```javascript\n   getUserByName('nolan').then(function(user) {\n     return getUserAccountById(user.id);\n   }).then(function(userAccount) {\n     // I got a user account!\n   });\n   ```\n\n   注意此处，我返回了第二个 promise ——返回 `return` 是关键，如果没有 `return` ，`getUserAccountById()` 就只会产生副作用，第二个 then 的处理函数就只能接收到 `undefined` 而不是 `userAccount`\n\n2. 返回一个同步的值（或 undefined）\n\n   返回 `undefined` 通常来说是一个错误，但返回一个同步的值，却是一种将同步代码转换为 promise 风格代码的很酷的方式。例如，我们有一份用户的缓存数据，我们可以做什么呢：\n\n   ```javascript\n   getUserByName('nolan').then(function(user) {\n     if (inMemoryCache[user.id]) {\n       return inMemoryCache[user.id]; // returning a synchronous value!\n     }\n     return getUserAccountById(user.id); // returning a promise!\n   }).then(function(userAccount) {\n     // I got a user account!\n   });\n   ```\n\n   这不是很酷么？第二个函数根本不用关心 `userAccount` 是同步获取的还是异步获取的，第一个函数也可以随意返回同步的值或者异步的值。\n\n   不幸的是，有个麻烦的事实摆在眼前：无返回值的函数，严格来说，都会默认返回 `undefined` ，意味着当你打算返回某些东西的时候，很容易在不经意间就产生副作用\n\n   出于这个原因，我的个人习惯是，总是在 `.then()` 函数内加上 `return` 或者 `throw` sth，我建议你也这样做\n\n3. 抛出同步的异常\n\n   说到 `throw` ，这是 promise 可以变得更加令人敬畏之处。比如说我们希望能够抛出一个同步的异常以防用户登出：\n\n   ```javascript\n   getUserByName('nolan').then(function(user) {\n     if (user.isLoggedOut()) {\n       throw new Error('user logged out!'); // throwing a synchronous error!\n     }\n     if (inMemoryCache[user.id]) {\n       return inMemoryCache[user.id]; // returning a synchronous value!\n     }\n     return getUserAccountById(user.id); // returning a promise!\n   }).then(function(userAccount) {\n     // I got a user account!\n   }).catch(function(err) {\n     // Boom, I got an error!\n   });\n   ```\n\n   上述代码中，如果用户登出，`catch()` 会捕获到一个同步的异常，并且如果任意一个 promise 变为 rejected 状态， `catch()` 会捕获到一个异步的异常。同样，`catch()` 函数无需关系捕获的异常是同步的还是异步的。\n\n   这在开发过程中确定代码异常极其有效！举个例子，在 `then()` 函数内部任意一处，我们执行 `JSON.parse()` 操作，如果是 JSON 是无效的，则会抛出一个同步的异常。在回调中，该异常会被掩盖；但在 promise 中，我们可以在 `catch()` 中轻松处理捕获到的异常。\n\n\n\n### 进阶错误\n\n既然你已经学到了可以让 promise 变得简单的单一技巧，不妨来看看一些边角案例，当然，编程总是会遇到边角案例\n\n之所以说这些案例是进阶的，是因为我发现那些已经相当擅长 promise 的程序员才犯这些错。如果想弄清楚文章开头提到的那个问题，我们就有必要研究清楚这些案例\n\n\n\n#### 进阶错误1：不知道 `Promise.resolve()`\n\n正如我在上面提到的，promise 非常擅长将同步代码封装为异步代码。然而，如果下面这段代码你敲得多了的话：\n\n```javascript\nnew Promise(function(resolve, reject) {\n  resolve(someSynchronousValue);\n}).then(/* ... */);\n```\n\n你可以用 `Promise.resolve()` 来更简洁的表明这一点：\n\n```javascript\nPromise.resolve(someSynchronousValue).then(/* ... */);\n```\n\n这在捕获任何同步的异常上也极其有效，正因如此，我已经养成了几乎所有 promise 返回API方法的习惯，如下所示：\n\n```javascript\nfunction somePromiseAPI() {\n  return Promise.resolve().then(function() {\n    doSomethingThatMayThrow();\n    return 'foo';\n  }).then(/* ... */);\n}\n```\n\n记住一点：任何可能同步抛出的代码，都可以在某处找到几乎不可能调试的隐藏的异常。如果你用 `Promise.solve()` 包裹一切同步代码，则你总是可以在之后通过 `catch()` 函数捕获异常\n\n相似的，你可以用 `Promise.reject()` 来返回一个状态立刻变为 `rejected` 的 promise 实例：\n\n```javascript\nPromise.reject(new Error('some awful error'));\n```\n\n\n\n#### 进阶错误2：`then(resolveHandler).catch(rejectHandler)` 并不全等于 `then(resolveHandler, rejectHandler)`\n\n上面提到的 `catch()` 是语法糖，因此如下两个代码片段是等价的：\n\n```javascript\nsomePromise().catch(function(err) {\n  // handle error\n});\n\nsomePromise().then(null, function(err) {\n  // handle error\n});\n```\n\n然而，下面两段代码却不是等价的：\n\n```javascript\nsomePromise().then(function() {\n  return someOtherPromise();\n}).catch(function(err) {\n  // handle error\n});\n\nsomePromise().then(function() {\n  return someOtherPromise();\n}, function(err) {\n  // handle error\n});\n```\n\n如果你还在疑惑为何不等价，不妨设想当第一个函数抛出异常时：\n\n```javascript\nsomePromise().then(function() {\n  throw new Error('oh noes');\n}).catch(function(err) {\n  // I caught your error! :)\n});\n\nsomePromise().then(function() {\n  throw new Error('oh noes');\n}, function(err) {\n  // I didn't catch your error! :(\n});\n```\n\n事实证明，当你使用 `then(resolveHandler, rejectHandler)` 格式时，如果 `resolveHandler` 自身抛出了异常，`rejectHandler` 是自然无法捕获到的\n\n为此，我自己的习惯是：从不使用 `then()` 函数的第二个参数，而是使用 `catch()`。例外则是，当我在写异步的[Mocha](http://mochajs.org/) 测试用例时，我会使用第二个参数来确保异常能够被抛出：\n\n```javascript\nit('should throw an error', function() {\n  return doSomethingThatThrows().then(function() {\n    throw new Error('I expected an error!');\n  }, function(err) {\n    should.exist(err);\n  });\n});\n```\n\n说到测试，在测试 promise API时，[Mocha](http://mochajs.org/) 和 [Chai](http://chaijs.com/) 是绝妙的组合。[pouchdb-plugin-seed](https://github.com/pouchdb/plugin-seed)项目中有一些简单的 [测试用例](https://github.com/pouchdb/plugin-seed/blob/master/test/test.js) 可以拿来练手\n\n\n\n#### 进阶错误3：promises VS promise factories\n\n或许你想按顺序一个一个的处理一组 promise，处理的方式近似于 `Promise.all()` ，但其中的 promise 却不是并发执行的\n\n你可能简单的认为理想的代码是这样的：\n\n```javascript\nfunction executeSequentially(promises) {\n  var result = Promise.resolve();\n  promise.forEach(function(promise) {\n    result = result.then(promise);\n  });\n  return result;\n}\n```\n\n实际上，上述代码无法达到你预期的效果，传递给 `executeSequentially()` 的多个 promise 仍然会并发执行\n\n发生这种情况的原因是你根本不想操作 promise 的数组，根据 promise 规范，一旦创建了 promise，它就会开始执行，你真正想要的是 promise factories 的数组\n\n```javascript\nfunction executeSequentially(promiseFactories) {\n  var result = Promise.resolve();\n  promiseFactories.forEach(function(promiseFactory) {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n```\n\n我知道你在想什么：“这个 Java 程序员到底是谁，为什么他在谈论 factories 呢？”promise factories 很简单，只是一个会返回一个 promise 实例的函数而已:\n\n```javascript\nfunction myPromiseFactory() {\n  return somethingThatCreatesAPromise();\n}\n```\n\n这管用么？管用！promise factory 只有被调用时才会生成 promise，它运行的方式类似于 `then` 函数——实际上，它们就是一回事\n\n观察上述的 `executeSequentially()` 函数，然后想象 `myPromiseFactory` 被替换进 `result.then(...)` 内部，之后豁然开朗，这时你才刚接触到 promise 的启蒙\n\n\n\n#### 进阶错误4：如果我想要两个 promise 实例的结果呢\n\n通常，一个 promise 实例将取决于另一个 promise 实例，但如果想要获取这两个 promise 实例的输出呢？比如说：\n\n```javascript\ngetUserByName('nolan').then(function(user) {\n  return getUserAccountById(user.id);\n}).then(function(userAccount) {\n  // 槽糕，我也需要获取 user 对象啊！\n});\n```\n\n既要当个优秀的JS程序员，又要避免“爆炸金字塔”的出现，我们或许应该将 `user` 对象存储在更高一级作用域的变量中：\n\n```javascript\nvar user;\ngetUserByName('nolan').then(function(result) {\n  user = result;\n  return getUserAccountById(user.id);\n}).then(function(userAccount) {\n  // 好了，user 和 userAccount 都可以获取到了\n});\n```\n\n这办法能用，但只是凑合。我的建议是：放开先前的偏见，拥抱金字塔：\n\n```javascript\ngetUserByName('nolan').then(function(user) {\n  return getUserAccountById(user.id).then(function(userAccount) {\n  // 你看，我也可以获取 user 和 userAccount \n  });\n});\n```\n\n至少，暂时的“拥抱金字塔”:)\n\n如果代码缩进变成了一个问题，那你可以做JS程序员“自古以来”一直在做的事——将函数提取到一个命名函数：\n\n```javascript\nfunction onGetUserAndUserAccount(user, userAccount) {\n  return doSomething(user, userAccount);\n}\n\nfunction onGetUser(user) {\n  return getUserAccountById(user.id).then(function(userAccount) {\n    return onGetUserAndUserAccount(user, userAccount);\n  });\n}\n\ngetUserByName('onlan')\n\t.then(onGetUser)\n\t.then(function() {\n  // 运行到这里时，doSomething() 已经执行完毕，我们的缩进归零了\n});\n```\n\n当你的 promise 代码越来越复杂时，你会发现你会将越来越多的函数提取到命名函数中，代码也会变得更加美观：\n\n```javascript\nputYourRightFootIn()\n\t.then(putYourRightFootOut)\n\t.then(putYourRightFootIn)\n\t.then(shakeItAllAbout);\n```\n\n这就是 promise 出现的意义！\n\n\n\n#### 进阶错误5：promise fall through 通过\n\n这是我在上面介绍 promise 时提到的错误，极其深奥的案例，或许永远都不会出现在你的代码里，但它着实让我吓了一跳\n\n看到如下代码你有什么想法么：\n\n```javascript\nPromise.resolve('foo').then(Promise.resolve('bar')).then(function(result) {\n  console.log(result);\n});\n```\n\n你可能觉得会打印 `bar`，但结果却是 `foo`\n\n原因在于，当你向 `then()` 传递一个非函数（例如 promise 实例）时，它实际上会将其看作 `then(null)` ，这会导致前一个 promise 的结果通过。你不妨试试：\n\n```javascript\nPromise.resolve('foo').then(null).then(function(result) {\n  console.log(result);\n});\n```\n\n就算中间加上无数的 `then(null)`，打印的结果仍然是 `foo`\n\n这实际上回到了之前关于 promise VS promise factories 的讨论。简单地说，你可以直接向 `then()` 方法中传入一个 promise 实例，但它却不会依照你希望的那样运行。`then()` 期望获取一个函数，所以大部分情况你的意思应该是：\n\n```javascript\nPromise.resolve('foo').then(function() {\n  return Promise.resolve('bar');\n}).then(function(result) {\n  console.log(result); // 结果是 bar，正如我们期望的\n});\n```\n\n所以记住一点：给 `then()` 传入的只能是函数（不要传别的什么）！\n\n\n\n\n\n### 答疑\n\n##### 题目一\n\n```javascript\ndoSomething().then(function() {\n  return doSomethingElse();\n}).then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|-----------------|\n                  doSomethingElse(undefined)\n                  |------------------|\n                                     finalHandler(resultOfDoSomethingElse)\n                                     |------------------|\n```\n\n\n\n##### 题目二\n\n```javascript\ndoSomething().then(function() {\n  doSomethingElse();\n}).then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|------------------|\n                   doSomethingElse(undefined)\n                   |------------------|\n                   finalHandler(undefined)\n                   |------------------|\n```\n\n\n\n##### 题目三\n\n```javascript\ndoSomething().then(doSomethingElse())\n\t.then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|------------------|\ndoSomethingElse(undefined)\n|---------------------------------|\n                   finalHandler(resultOfDoSomething)\n                   |------------------|\n```\n\n\n\n##### 题目四\n\n```javascript\ndoSomething().then(doSomethingElse)\n\t.then(finalHandler);\n```\n\n答案：\n\n```javascript\ndoSomething\n|-----------------|\n                  doSomethingElse(resultOfDoSomething)\n                  |-----------------|\n                                    finalHandler(resultOfDoSomethingElse)\n                                    |-----------------|\n```\n\n\n\n如果还是不太明白这些答案，我建议你重新再把这篇文章看一遍，或者自己定义 `doSomething()` 和 `doSomethingElse()` 这两个方法，放到浏览器里试试\n\n\n\n> 说明：这些给出的例子，我假定 `doSomething()` 和 `doSomethingElse()` 都返回 promise，并且这些 promise 表示在 JavaScript 事件循环之外完成的事（例如 IndexedDB、network、setTimeout），这就是为什么在合适的情况下，它们显示成并发，[演示](http://jsbin.com/tuqukakawo/1/edit?js,console,output)\n\n\n\npromise 的更多进阶用法—— [promise protips chear sheet](https://gist.github.com/nolanlawson/6ce81186421d2fa109a4)\n\n\n\n#### 关于 promise 的最后几句话\n\nPromise 是伟大的，如果你仍然在使用回调（嵌套），我强烈建议你讲代码转换为 promise 风格，你的代码将变得更加紧凑、优雅、更具可读性\n\n不信？你看这个例子：[a refactor of PouchDB's map/reduce module](https://t.co/hRyc6ENYGC) 其中用 promise 取代回调，结果是：290个插入操作，555个删除操作\n\n顺带提一句，那个写出恶心的回调嵌套代码的人，其实是我自己，所以这也算是我在 promise 原初魔力的第一课，同时感谢其他 PouchDB 的贡献者一路对我的指导\n\n话虽如此，promise 并非完美，但就像是瘦死的骆驼比马大，promise 仍旧要好过回调，因此就目前而言，其中一个要比另一个更接近“完美”，但是如果你有机会选择更好的，那就要尽力避免它们俩\n\n虽然优于回调，promise 仍然难以理解且极易出错，正因如此我才写下这篇文章讲明其中事实。新手和专家都会经常混淆这些概念，真的，这不是他们的错，问题在于 promise ——虽然近似于我们在同步代码中使用的模式，看起来是个不错的替代品，但却不是百分之百相同\n\n实际上，你不应该学习一堆神秘的规则和新的 API 来做这些事，在同步的世界里，你可以完全使用你熟悉的模式，如 `return`、`catch`、`throw`和 `for` 循环。你的脑子里不应该始终有两套系统并行！\n\n\n\n#### Awaiting async/await\n\n这是我另一篇文章 [Taming the asynchronous beast with ES7](http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html) 中讨论的要点，其中我研究了 ES7 的关键字 `async`/`await`，以及它们如何将 promise 深层次的融合到 JS 这门语言中。相比于写伪同步代码（其中提供的 `catch()` 方法看似与 `catch` 一致，实则不然），ES7 允许我们使用真正的 `try`/`catch`/`return` 关键字，正如我们在 CS 101 里学到的那样\n\n\n\n就 JS 这门语言来说，这是一个巨大的福音。因为最终，只要工具不在我们犯错时及时提示，这些 promise 反模式就总是会不经意出现\n\n\n\n以 JS 的历史为例，我认为 [JSLint](http://jslint.com/) 和 [JSHint](http://jshint.com/) 对 JS 社区做出的贡献要比 [JS 语言精粹](http://amzn.com/0596517742) 要多，即使它们有效的包含相同的信息。这就像是“明确指出你的代码中何处出错了”和“通过阅读一本书来试图搞清楚别人的代码是怎么出错的”的区别\n\n\n\nES7 的 `async`/`await` 的美在于，在大多数情况下，代码中的错误会将自己显示为语法、编译器错误，而不是运行时的微妙的错误。不过，在那之前，熟悉并掌握 promise，以及如何在 ES5 和 ES6 中正确使用是一件好事\n\n但我却意识到一点，就像是《JS 语言精粹》这本书一样，这篇文章所能提供的影响是有限的。但当你看到他们犯同样的错误时，你完全有能力指出其中的错误，因为我们中有太多的人需要承认一点：我还并没有百分之百掌握 promise ！\n\n\n\n> 更新：需要指出的一点是：Bluebird 3.0 将会提供告警信息以避免我在本文中提到的许多错误。所以，在 ES7 完全推出之前，Bluebird 会是另一个非常不错的选择\n\n\n\n[原文地址](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)\n\n","slug":"译-Promise-rookie","published":1,"updated":"2019-10-16T07:16:41.781Z","_id":"ck1sxw4xm0001gn4mgtw8v897","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JS程序员们，是时候承认了：我们的 promise 有问题</p>\n<p>等等，我不是说 promise 本身有问题，基于 <a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">A+ 规范</a> 编写的 Promise 自然是无懈可击</p>\n<p>我说的这个问题在过去的一年里反复出现，我见到了无数的程序员栽在了 PouchDB API 和其他深度基于 promise 的 API 上：</p>\n<p>我们中的绝大多数对 promise 的使用只停留在一知半解的层面</p>\n<p>不信？不妨看看我在推特上 po 出的 <a href=\"https://twitter.com/nolanlawson/status/578948854411878400\" target=\"_blank\" rel=\"noopener\">题目</a>：</p>\n<h4 id=\"以下四个-promise-有什么区别\"><a href=\"#以下四个-promise-有什么区别\" class=\"headerlink\" title=\"以下四个 promise 有什么区别\"></a>以下四个 <code>promise</code> 有什么区别</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> doSomethingElse();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tdoSomethingElse();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething().then(doSomethingElse());</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>\n<p>答案在本文的末尾</p>\n<h3 id=\"为什么要使用-promise\"><a href=\"#为什么要使用-promise\" class=\"headerlink\" title=\"为什么要使用 promise\"></a>为什么要使用 promise</h3><p>如果你读过 promise 相关文章，你会发现有一个名词会被经常提到——<a href=\"https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf\" target=\"_blank\" rel=\"noopener\">the pyramid of doom 末日金字塔</a> ——一些可怕的回调代码，层层嵌套，稳定地向屏幕右侧延伸</p>\n<p>Promise 的出现确实解决了这个问题，但它的作用不仅限于减少代码缩进！正如 <a href=\"http://youtu.be/hf1T_AONQJU\" target=\"_blank\" rel=\"noopener\">Redemption from Callback Hell</a> 中解释的，回调带来的真正问题是它剥夺了我们使用 <code>return</code> 和 <code>throw</code> 的权利，与此同时，我们的程序的整个流程都是基于副作用：一个函数顺带调用另一个函数</p>\n<p>实际上，回调“作的恶”不止于此：它让我们与栈隔绝（栈：在编程语言中通常用来保证程序顺利运行的东西）！脱离栈写代码就像是开着一辆没有刹车的车一样危险——你根本不知道自己的处境有多危险，知道危险来临，你需要它时才发现它不在!</p>\n<p>Promise 的重点在于，在我们写异步代码时，让我们重拾丢失的语言规范：<code>return</code>、<code>throw</code> 以及栈。</p>\n<p>但你必须知道如何正确使用 promise 才能充分享受它带来的好处，否则只会是驱虎吞狼、后患无穷</p>\n<h3 id=\"初阶错误\"><a href=\"#初阶错误\" class=\"headerlink\" title=\"初阶错误\"></a>初阶错误</h3><h4 id=\"新手错误：promise的末日金字塔\"><a href=\"#新手错误：promise的末日金字塔\" class=\"headerlink\" title=\"新手错误：promise的末日金字塔\"></a>新手错误：promise的末日金字塔</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remotedb.allDocs(&#123;</span><br><span class=\"line\">\tinclude_docs: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tattachments: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> docs = result.rows;</span><br><span class=\"line\">\tdocs.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">\t\tlocaldb.put(element.doc).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">\t\t\talert(<span class=\"string\">\"Pulled doc with id \"</span> + element.doc._id + <span class=\"string\">\" and added to local db.\"</span>);</span><br><span class=\"line\">\t\t&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (err.name == <span class=\"string\">'conflict'</span>) &#123;</span><br><span class=\"line\">\t\t\t\tlocaldb.get(element.doc._id).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resp</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tlocaldb.remove(resp._id, resp._rev).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resp</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// ... 诸如此类</span></span><br><span class=\"line\">\t\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>改进版：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remotedb.allDocs(...).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resultOfAllDocs</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localdb.put(...);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resultOfPut</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localdb.get(...);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resultOfGet</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localdb.put(...);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这被称为 <code>composing promises</code> 即“合成promises”，这是 <code>promises</code> 所提供的强大魔力之一。每一个方法只会在前一个 <code>promise</code> 转变为 <code>resolved</code> 状态时被调用，并且可以获取前一个 <code>promise</code> 的结果</p>\n<h4 id=\"新手错误2：forEach-循环-与-promise-如何兼得\"><a href=\"#新手错误2：forEach-循环-与-promise-如何兼得\" class=\"headerlink\" title=\"新手错误2：forEach()/循环 与 promise 如何兼得\"></a>新手错误2：<code>forEach()/循环</code> 与 <code>promise</code> 如何兼得</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我想通过 remove() 处理所有文档</span></span><br><span class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">\tresult.rows.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rows</span>) </span>&#123;</span><br><span class=\"line\">\t\tdb.remove(row.doc);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 我认为所有文档都被移除了 ha?</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码有什么问题？问题在于，第一个 function 会返回 undefined，意味着第二个 function 不会等待所有文档都执行 db.remove()。实际上，它根本什么都不会等，任意数目的文档被移除时，第二个方法都会执行。</p>\n<p>解决的方法是，应该用 <code>Promise.all()</code> 来替代 <code>forEach()</code>/<code>for</code>/<code>while</code> 处理异步循环<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resp</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(result.rows.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">row</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> db.remove(row.doc);</span><br><span class=\"line\">\t&#125;));</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arrayOfResults</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 此时，所有文档才真正被移除</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这到底发生了什么？简单来说，<code>Promise.all()</code> 以一个包含多个 promise 的数组作为输入，返回另一个 promise 作为输出，只有当输入数组中的所有 promise 的状态都转变为 <code>resolved</code>，该输出的 promise 状态才会变成 <code>resolved</code>，相当于异步的for循环</p>\n<p><code>Promise.all()</code> 也会向随后的处理函数传递一个包含所有结果的数组，这是非常有用的，例如，试图通过 <code>get()</code> 从 PouchDB 中获取多个数据。如果输入数组中包含的 promise，有任意一个状态转变为 <code>rejected</code>，该 <code>all()</code>的 promise 都会变为 <code>rejected</code></p>\n<h4 id=\"新手错误3：忘记加上-catch\"><a href=\"#新手错误3：忘记加上-catch\" class=\"headerlink\" title=\"新手错误3：忘记加上 .catch()\"></a>新手错误3：忘记加上 <code>.catch()</code></h4><p>这是另一个常见的错误。简单的认为他们写的promise绝不会抛出错误，很多开发者都会忘记在 promise 链的末尾加上 <code>.catch()</code>。一旦如此，promise 中任何被抛出的错误都会被掩盖，甚至无法再 console 中展现，无疑会提高 debug 的难度</p>\n<p>为避免上述情况的发生，我建议在每一个promise链的末尾都加上 <code>.catch()</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> anotherPromise();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> yetAnotherPromise();</span><br><span class=\"line\">&#125;).catch(<span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>)); <span class=\"comment\">// &lt;-- this is badass</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"新手错误4：使用-deferred\"><a href=\"#新手错误4：使用-deferred\" class=\"headerlink\" title=\"新手错误4：使用 deferred\"></a>新手错误4：使用 <code>deferred</code></h4><p>我总是能看到这类<a href=\"http://gonehybrid.com/how-to-use-pouchdb-sqlite-for-local-storage-in-your-ionic-app/\" target=\"_blank\" rel=\"noopener\">错误</a>，以至于我现在都不愿意重复这个单词</p>\n<p>简而言之，promise有一段漫长且曲折的历史，JS社区花费了大量的时间来纠正期间的错误。在promise发展的早期，jQuery 和 Angular 都通过 “deferred” 来实现各自的 promise，而现如今都被 ES6 的 promise 所取代，例如Q、when、RSVP、Bluebird、Lie等库都实现了符合 promise/A+ 规范的 promise</p>\n<p>如何避免使用 deferred 呢？</p>\n<p>首先，绝大多数 promise 库都会为你引入第三方库实现的 promise 的方法。例如，Angular 中的 <code>$q</code> 模块允许你通过 <code>$q.when()</code> 来包裹不符合 <code>$q</code> 规范的 promise。所以，Angular 使用者可以这样包裹 PouchDB promises：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$q.when(db.put(doc)).then(<span class=\"comment\">/* ... */</span>); <span class=\"comment\">// &lt;-- 这就是你迫切需要的</span></span><br></pre></td></tr></table></figure>\n<p>另一个方法是使用<a href=\"https://blog.domenic.me/the-revealing-constructor-pattern/\" target=\"_blank\" rel=\"noopener\">revealing constructor pattern</a>来包裹非 promise 的API。例如，封装基于回调的API，比如说 Nodejs 中的 <code>fs.readFile()</code>，可以这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(<span class=\"string\">'myfile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, file</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resolve(file);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"新手错误5：使用副作用而不是返回\"><a href=\"#新手错误5：使用副作用而不是返回\" class=\"headerlink\" title=\"新手错误5：使用副作用而不是返回\"></a>新手错误5：使用副作用而不是返回</h4><p>以下代码有什么问题？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  someOtherPromise();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我希望 someOtherPromise() 已经是 resolved 状态了</span></span><br><span class=\"line\">  <span class=\"comment\">// 事实却告诉我，它不是</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>是时候来详细了解 promise 的各个要点了</p>\n<p>正如我之前所说，promise 的魔力在于它回馈我们之前的 <code>return</code> 和 <code>throw</code>。实际中是如何体现的呢？</p>\n<p>每一个 promise 都会为你提供一个 <code>then()</code> 方法（或者 <code>catch()</code>方法，<code>then(null, ...)</code> 的语法糖）。让我们进入 <code>then()</code> 函数的内部：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 现在是 then() 函数的内部</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>我们在 <code>then()</code> 函数内部可以做什么？有三件事是可以做的：</p>\n<ol>\n<li><p><code>return</code> 另一个 promise</p>\n</li>\n<li><p><code>return</code> 一个同步的值（或 <code>undefined</code>）</p>\n</li>\n<li><p><code>throw</code> 一个同步的 error</p>\n</li>\n</ol>\n<p>一旦你掌握其中的诀窍，你就解开了 promise 的魔术。让我们逐点分析：</p>\n<ol>\n<li><p>返回另一个 promise</p>\n<p>这个模式在 promise 相关文章中很常见，就像上面提到的“合成promise”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意此处，我返回了第二个 promise ——返回 <code>return</code> 是关键，如果没有 <code>return</code> ，<code>getUserAccountById()</code> 就只会产生副作用，第二个 then 的处理函数就只能接收到 <code>undefined</code> 而不是 <code>userAccount</code></p>\n</li>\n<li><p>返回一个同步的值（或 undefined）</p>\n<p>返回 <code>undefined</code> 通常来说是一个错误，但返回一个同步的值，却是一种将同步代码转换为 promise 风格代码的很酷的方式。例如，我们有一份用户的缓存数据，我们可以做什么呢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id]; <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id); <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这不是很酷么？第二个函数根本不用关心 <code>userAccount</code> 是同步获取的还是异步获取的，第一个函数也可以随意返回同步的值或者异步的值。</p>\n<p>不幸的是，有个麻烦的事实摆在眼前：无返回值的函数，严格来说，都会默认返回 <code>undefined</code> ，意味着当你打算返回某些东西的时候，很容易在不经意间就产生副作用</p>\n<p>出于这个原因，我的个人习惯是，总是在 <code>.then()</code> 函数内加上 <code>return</code> 或者 <code>throw</code> sth，我建议你也这样做</p>\n</li>\n<li><p>抛出同步的异常</p>\n<p>说到 <code>throw</code> ，这是 promise 可以变得更加令人敬畏之处。比如说我们希望能够抛出一个同步的异常以防用户登出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user.isLoggedOut()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'user logged out!'</span>); <span class=\"comment\">// throwing a synchronous error!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id]; <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id); <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Boom, I got an error!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，如果用户登出，<code>catch()</code> 会捕获到一个同步的异常，并且如果任意一个 promise 变为 rejected 状态， <code>catch()</code> 会捕获到一个异步的异常。同样，<code>catch()</code> 函数无需关系捕获的异常是同步的还是异步的。</p>\n<p>这在开发过程中确定代码异常极其有效！举个例子，在 <code>then()</code> 函数内部任意一处，我们执行 <code>JSON.parse()</code> 操作，如果是 JSON 是无效的，则会抛出一个同步的异常。在回调中，该异常会被掩盖；但在 promise 中，我们可以在 <code>catch()</code> 中轻松处理捕获到的异常。</p>\n</li>\n</ol>\n<h3 id=\"进阶错误\"><a href=\"#进阶错误\" class=\"headerlink\" title=\"进阶错误\"></a>进阶错误</h3><p>既然你已经学到了可以让 promise 变得简单的单一技巧，不妨来看看一些边角案例，当然，编程总是会遇到边角案例</p>\n<p>之所以说这些案例是进阶的，是因为我发现那些已经相当擅长 promise 的程序员才犯这些错。如果想弄清楚文章开头提到的那个问题，我们就有必要研究清楚这些案例</p>\n<h4 id=\"进阶错误1：不知道-Promise-resolve\"><a href=\"#进阶错误1：不知道-Promise-resolve\" class=\"headerlink\" title=\"进阶错误1：不知道 Promise.resolve()\"></a>进阶错误1：不知道 <code>Promise.resolve()</code></h4><p>正如我在上面提到的，promise 非常擅长将同步代码封装为异步代码。然而，如果下面这段代码你敲得多了的话：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  resolve(someSynchronousValue);</span><br><span class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>);</span><br></pre></td></tr></table></figure>\n<p>你可以用 <code>Promise.resolve()</code> 来更简洁的表明这一点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(someSynchronousValue).then(<span class=\"comment\">/* ... */</span>);</span><br></pre></td></tr></table></figure>\n<p>这在捕获任何同步的异常上也极其有效，正因如此，我已经养成了几乎所有 promise 返回API方法的习惯，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somePromiseAPI</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    doSomethingThatMayThrow();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</span><br><span class=\"line\">  &#125;).then(<span class=\"comment\">/* ... */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记住一点：任何可能同步抛出的代码，都可以在某处找到几乎不可能调试的隐藏的异常。如果你用 <code>Promise.solve()</code> 包裹一切同步代码，则你总是可以在之后通过 <code>catch()</code> 函数捕获异常</p>\n<p>相似的，你可以用 <code>Promise.reject()</code> 来返回一个状态立刻变为 <code>rejected</code> 的 promise 实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some awful error'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"进阶错误2：then-resolveHandler-catch-rejectHandler-并不全等于-then-resolveHandler-rejectHandler\"><a href=\"#进阶错误2：then-resolveHandler-catch-rejectHandler-并不全等于-then-resolveHandler-rejectHandler\" class=\"headerlink\" title=\"进阶错误2：then(resolveHandler).catch(rejectHandler) 并不全等于 then(resolveHandler, rejectHandler)\"></a>进阶错误2：<code>then(resolveHandler).catch(rejectHandler)</code> 并不全等于 <code>then(resolveHandler, rejectHandler)</code></h4><p>上面提到的 <code>catch()</code> 是语法糖，因此如下两个代码片段是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然而，下面两段代码却不是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你还在疑惑为何不等价，不妨设想当第一个函数抛出异常时：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I caught your error! :)</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I didn't catch your error! :(</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>事实证明，当你使用 <code>then(resolveHandler, rejectHandler)</code> 格式时，如果 <code>resolveHandler</code> 自身抛出了异常，<code>rejectHandler</code> 是自然无法捕获到的</p>\n<p>为此，我自己的习惯是：从不使用 <code>then()</code> 函数的第二个参数，而是使用 <code>catch()</code>。例外则是，当我在写异步的<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a> 测试用例时，我会使用第二个参数来确保异常能够被抛出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'should throw an error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doSomethingThatThrows().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'I expected an error!'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    should.exist(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>说到测试，在测试 promise API时，<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a> 和 <a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"noopener\">Chai</a> 是绝妙的组合。<a href=\"https://github.com/pouchdb/plugin-seed\" target=\"_blank\" rel=\"noopener\">pouchdb-plugin-seed</a>项目中有一些简单的 <a href=\"https://github.com/pouchdb/plugin-seed/blob/master/test/test.js\" target=\"_blank\" rel=\"noopener\">测试用例</a> 可以拿来练手</p>\n<h4 id=\"进阶错误3：promises-VS-promise-factories\"><a href=\"#进阶错误3：promises-VS-promise-factories\" class=\"headerlink\" title=\"进阶错误3：promises VS promise factories\"></a>进阶错误3：promises VS promise factories</h4><p>或许你想按顺序一个一个的处理一组 promise，处理的方式近似于 <code>Promise.all()</code> ，但其中的 promise 却不是并发执行的</p>\n<p>你可能简单的认为理想的代码是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  promise.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) </span>&#123;</span><br><span class=\"line\">    result = result.then(promise);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，上述代码无法达到你预期的效果，传递给 <code>executeSequentially()</code> 的多个 promise 仍然会并发执行</p>\n<p>发生这种情况的原因是你根本不想操作 promise 的数组，根据 promise 规范，一旦创建了 promise，它就会开始执行，你真正想要的是 promise factories 的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promiseFactories</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  promiseFactories.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promiseFactory</span>) </span>&#123;</span><br><span class=\"line\">    result = result.then(promiseFactory);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我知道你在想什么：“这个 Java 程序员到底是谁，为什么他在谈论 factories 呢？”promise factories 很简单，只是一个会返回一个 promise 实例的函数而已:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myPromiseFactory</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> somethingThatCreatesAPromise();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这管用么？管用！promise factory 只有被调用时才会生成 promise，它运行的方式类似于 <code>then</code> 函数——实际上，它们就是一回事</p>\n<p>观察上述的 <code>executeSequentially()</code> 函数，然后想象 <code>myPromiseFactory</code> 被替换进 <code>result.then(...)</code> 内部，之后豁然开朗，这时你才刚接触到 promise 的启蒙</p>\n<h4 id=\"进阶错误4：如果我想要两个-promise-实例的结果呢\"><a href=\"#进阶错误4：如果我想要两个-promise-实例的结果呢\" class=\"headerlink\" title=\"进阶错误4：如果我想要两个 promise 实例的结果呢\"></a>进阶错误4：如果我想要两个 promise 实例的结果呢</h4><p>通常，一个 promise 实例将取决于另一个 promise 实例，但如果想要获取这两个 promise 实例的输出呢？比如说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 槽糕，我也需要获取 user 对象啊！</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>既要当个优秀的JS程序员，又要避免“爆炸金字塔”的出现，我们或许应该将 <code>user</code> 对象存储在更高一级作用域的变量中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user;</span><br><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  user = result;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 好了，user 和 userAccount 都可以获取到了</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这办法能用，但只是凑合。我的建议是：放开先前的偏见，拥抱金字塔：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 你看，我也可以获取 user 和 userAccount </span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>至少，暂时的“拥抱金字塔”:)</p>\n<p>如果代码缩进变成了一个问题，那你可以做JS程序员“自古以来”一直在做的事——将函数提取到一个命名函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUserAndUserAccount</span>(<span class=\"params\">user, userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doSomething(user, userAccount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUser</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserByName(<span class=\"string\">'onlan'</span>)</span><br><span class=\"line\">\t.then(onGetUser)</span><br><span class=\"line\">\t.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 运行到这里时，doSomething() 已经执行完毕，我们的缩进归零了</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当你的 promise 代码越来越复杂时，你会发现你会将越来越多的函数提取到命名函数中，代码也会变得更加美观：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">putYourRightFootIn()</span><br><span class=\"line\">\t.then(putYourRightFootOut)</span><br><span class=\"line\">\t.then(putYourRightFootIn)</span><br><span class=\"line\">\t.then(shakeItAllAbout);</span><br></pre></td></tr></table></figure>\n<p>这就是 promise 出现的意义！</p>\n<h4 id=\"进阶错误5：promise-fall-through-通过\"><a href=\"#进阶错误5：promise-fall-through-通过\" class=\"headerlink\" title=\"进阶错误5：promise fall through 通过\"></a>进阶错误5：promise fall through 通过</h4><p>这是我在上面介绍 promise 时提到的错误，极其深奥的案例，或许永远都不会出现在你的代码里，但它着实让我吓了一跳</p>\n<p>看到如下代码你有什么想法么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>)).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>你可能觉得会打印 <code>bar</code>，但结果却是 <code>foo</code></p>\n<p>原因在于，当你向 <code>then()</code> 传递一个非函数（例如 promise 实例）时，它实际上会将其看作 <code>then(null)</code> ，这会导致前一个 promise 的结果通过。你不妨试试：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"literal\">null</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就算中间加上无数的 <code>then(null)</code>，打印的结果仍然是 <code>foo</code></p>\n<p>这实际上回到了之前关于 promise VS promise factories 的讨论。简单地说，你可以直接向 <code>then()</code> 方法中传入一个 promise 实例，但它却不会依照你希望的那样运行。<code>then()</code> 期望获取一个函数，所以大部分情况你的意思应该是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 结果是 bar，正如我们期望的</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>所以记住一点：给 <code>then()</code> 传入的只能是函数（不要传别的什么）！</p>\n<h3 id=\"答疑\"><a href=\"#答疑\" class=\"headerlink\" title=\"答疑\"></a>答疑</h3><h5 id=\"题目一\"><a href=\"#题目一\" class=\"headerlink\" title=\"题目一\"></a>题目一</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doSomethingElse();</span><br><span class=\"line\">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|-----------------|</span><br><span class=\"line\">                  doSomethingElse(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                  |------------------|</span><br><span class=\"line\">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class=\"line\">                                     |------------------|</span><br></pre></td></tr></table></figure>\n<h5 id=\"题目二\"><a href=\"#题目二\" class=\"headerlink\" title=\"题目二\"></a>题目二</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  doSomethingElse();</span><br><span class=\"line\">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|------------------|</span><br><span class=\"line\">                   doSomethingElse(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                   |------------------|</span><br><span class=\"line\">                   finalHandler(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                   |------------------|</span><br></pre></td></tr></table></figure>\n<h5 id=\"题目三\"><a href=\"#题目三\" class=\"headerlink\" title=\"题目三\"></a>题目三</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(doSomethingElse())</span><br><span class=\"line\">\t.then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|------------------|</span><br><span class=\"line\">doSomethingElse(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">|---------------------------------|</span><br><span class=\"line\">                   finalHandler(resultOfDoSomething)</span><br><span class=\"line\">                   |------------------|</span><br></pre></td></tr></table></figure>\n<h5 id=\"题目四\"><a href=\"#题目四\" class=\"headerlink\" title=\"题目四\"></a>题目四</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(doSomethingElse)</span><br><span class=\"line\">\t.then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|-----------------|</span><br><span class=\"line\">                  doSomethingElse(resultOfDoSomething)</span><br><span class=\"line\">                  |-----------------|</span><br><span class=\"line\">                                    finalHandler(resultOfDoSomethingElse)</span><br><span class=\"line\">                                    |-----------------|</span><br></pre></td></tr></table></figure>\n<p>如果还是不太明白这些答案，我建议你重新再把这篇文章看一遍，或者自己定义 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 这两个方法，放到浏览器里试试</p>\n<blockquote>\n<p>说明：这些给出的例子，我假定 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 都返回 promise，并且这些 promise 表示在 JavaScript 事件循环之外完成的事（例如 IndexedDB、network、setTimeout），这就是为什么在合适的情况下，它们显示成并发，<a href=\"http://jsbin.com/tuqukakawo/1/edit?js,console,output\" target=\"_blank\" rel=\"noopener\">演示</a></p>\n</blockquote>\n<p>promise 的更多进阶用法—— <a href=\"https://gist.github.com/nolanlawson/6ce81186421d2fa109a4\" target=\"_blank\" rel=\"noopener\">promise protips chear sheet</a></p>\n<h4 id=\"关于-promise-的最后几句话\"><a href=\"#关于-promise-的最后几句话\" class=\"headerlink\" title=\"关于 promise 的最后几句话\"></a>关于 promise 的最后几句话</h4><p>Promise 是伟大的，如果你仍然在使用回调（嵌套），我强烈建议你讲代码转换为 promise 风格，你的代码将变得更加紧凑、优雅、更具可读性</p>\n<p>不信？你看这个例子：<a href=\"https://t.co/hRyc6ENYGC\" target=\"_blank\" rel=\"noopener\">a refactor of PouchDB’s map/reduce module</a> 其中用 promise 取代回调，结果是：290个插入操作，555个删除操作</p>\n<p>顺带提一句，那个写出恶心的回调嵌套代码的人，其实是我自己，所以这也算是我在 promise 原初魔力的第一课，同时感谢其他 PouchDB 的贡献者一路对我的指导</p>\n<p>话虽如此，promise 并非完美，但就像是瘦死的骆驼比马大，promise 仍旧要好过回调，因此就目前而言，其中一个要比另一个更接近“完美”，但是如果你有机会选择更好的，那就要尽力避免它们俩</p>\n<p>虽然优于回调，promise 仍然难以理解且极易出错，正因如此我才写下这篇文章讲明其中事实。新手和专家都会经常混淆这些概念，真的，这不是他们的错，问题在于 promise ——虽然近似于我们在同步代码中使用的模式，看起来是个不错的替代品，但却不是百分之百相同</p>\n<p>实际上，你不应该学习一堆神秘的规则和新的 API 来做这些事，在同步的世界里，你可以完全使用你熟悉的模式，如 <code>return</code>、<code>catch</code>、<code>throw</code>和 <code>for</code> 循环。你的脑子里不应该始终有两套系统并行！</p>\n<h4 id=\"Awaiting-async-await\"><a href=\"#Awaiting-async-await\" class=\"headerlink\" title=\"Awaiting async/await\"></a>Awaiting async/await</h4><p>这是我另一篇文章 <a href=\"http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html\" target=\"_blank\" rel=\"noopener\">Taming the asynchronous beast with ES7</a> 中讨论的要点，其中我研究了 ES7 的关键字 <code>async</code>/<code>await</code>，以及它们如何将 promise 深层次的融合到 JS 这门语言中。相比于写伪同步代码（其中提供的 <code>catch()</code> 方法看似与 <code>catch</code> 一致，实则不然），ES7 允许我们使用真正的 <code>try</code>/<code>catch</code>/<code>return</code> 关键字，正如我们在 CS 101 里学到的那样</p>\n<p>就 JS 这门语言来说，这是一个巨大的福音。因为最终，只要工具不在我们犯错时及时提示，这些 promise 反模式就总是会不经意出现</p>\n<p>以 JS 的历史为例，我认为 <a href=\"http://jslint.com/\" target=\"_blank\" rel=\"noopener\">JSLint</a> 和 <a href=\"http://jshint.com/\" target=\"_blank\" rel=\"noopener\">JSHint</a> 对 JS 社区做出的贡献要比 <a href=\"http://amzn.com/0596517742\" target=\"_blank\" rel=\"noopener\">JS 语言精粹</a> 要多，即使它们有效的包含相同的信息。这就像是“明确指出你的代码中何处出错了”和“通过阅读一本书来试图搞清楚别人的代码是怎么出错的”的区别</p>\n<p>ES7 的 <code>async</code>/<code>await</code> 的美在于，在大多数情况下，代码中的错误会将自己显示为语法、编译器错误，而不是运行时的微妙的错误。不过，在那之前，熟悉并掌握 promise，以及如何在 ES5 和 ES6 中正确使用是一件好事</p>\n<p>但我却意识到一点，就像是《JS 语言精粹》这本书一样，这篇文章所能提供的影响是有限的。但当你看到他们犯同样的错误时，你完全有能力指出其中的错误，因为我们中有太多的人需要承认一点：我还并没有百分之百掌握 promise ！</p>\n<blockquote>\n<p>更新：需要指出的一点是：Bluebird 3.0 将会提供告警信息以避免我在本文中提到的许多错误。所以，在 ES7 完全推出之前，Bluebird 会是另一个非常不错的选择</p>\n</blockquote>\n<p><a href=\"https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>JS程序员们，是时候承认了：我们的 promise 有问题</p>\n<p>等等，我不是说 promise 本身有问题，基于 <a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">A+ 规范</a> 编写的 Promise 自然是无懈可击</p>\n<p>我说的这个问题在过去的一年里反复出现，我见到了无数的程序员栽在了 PouchDB API 和其他深度基于 promise 的 API 上：</p>\n<p>我们中的绝大多数对 promise 的使用只停留在一知半解的层面</p>\n<p>不信？不妨看看我在推特上 po 出的 <a href=\"https://twitter.com/nolanlawson/status/578948854411878400\" target=\"_blank\" rel=\"noopener\">题目</a>：</p>\n<h4 id=\"以下四个-promise-有什么区别\"><a href=\"#以下四个-promise-有什么区别\" class=\"headerlink\" title=\"以下四个 promise 有什么区别\"></a>以下四个 <code>promise</code> 有什么区别</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> doSomethingElse();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tdoSomethingElse();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething().then(doSomethingElse());</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>\n<p>答案在本文的末尾</p>\n<h3 id=\"为什么要使用-promise\"><a href=\"#为什么要使用-promise\" class=\"headerlink\" title=\"为什么要使用 promise\"></a>为什么要使用 promise</h3><p>如果你读过 promise 相关文章，你会发现有一个名词会被经常提到——<a href=\"https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf\" target=\"_blank\" rel=\"noopener\">the pyramid of doom 末日金字塔</a> ——一些可怕的回调代码，层层嵌套，稳定地向屏幕右侧延伸</p>\n<p>Promise 的出现确实解决了这个问题，但它的作用不仅限于减少代码缩进！正如 <a href=\"http://youtu.be/hf1T_AONQJU\" target=\"_blank\" rel=\"noopener\">Redemption from Callback Hell</a> 中解释的，回调带来的真正问题是它剥夺了我们使用 <code>return</code> 和 <code>throw</code> 的权利，与此同时，我们的程序的整个流程都是基于副作用：一个函数顺带调用另一个函数</p>\n<p>实际上，回调“作的恶”不止于此：它让我们与栈隔绝（栈：在编程语言中通常用来保证程序顺利运行的东西）！脱离栈写代码就像是开着一辆没有刹车的车一样危险——你根本不知道自己的处境有多危险，知道危险来临，你需要它时才发现它不在!</p>\n<p>Promise 的重点在于，在我们写异步代码时，让我们重拾丢失的语言规范：<code>return</code>、<code>throw</code> 以及栈。</p>\n<p>但你必须知道如何正确使用 promise 才能充分享受它带来的好处，否则只会是驱虎吞狼、后患无穷</p>\n<h3 id=\"初阶错误\"><a href=\"#初阶错误\" class=\"headerlink\" title=\"初阶错误\"></a>初阶错误</h3><h4 id=\"新手错误：promise的末日金字塔\"><a href=\"#新手错误：promise的末日金字塔\" class=\"headerlink\" title=\"新手错误：promise的末日金字塔\"></a>新手错误：promise的末日金字塔</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remotedb.allDocs(&#123;</span><br><span class=\"line\">\tinclude_docs: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\tattachments: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> docs = result.rows;</span><br><span class=\"line\">\tdocs.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">\t\tlocaldb.put(element.doc).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">\t\t\talert(<span class=\"string\">\"Pulled doc with id \"</span> + element.doc._id + <span class=\"string\">\" and added to local db.\"</span>);</span><br><span class=\"line\">\t\t&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (err.name == <span class=\"string\">'conflict'</span>) &#123;</span><br><span class=\"line\">\t\t\t\tlocaldb.get(element.doc._id).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resp</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\tlocaldb.remove(resp._id, resp._rev).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resp</span>) </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// ... 诸如此类</span></span><br><span class=\"line\">\t\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t\t&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>改进版：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remotedb.allDocs(...).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resultOfAllDocs</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localdb.put(...);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resultOfPut</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localdb.get(...);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resultOfGet</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> localdb.put(...);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这被称为 <code>composing promises</code> 即“合成promises”，这是 <code>promises</code> 所提供的强大魔力之一。每一个方法只会在前一个 <code>promise</code> 转变为 <code>resolved</code> 状态时被调用，并且可以获取前一个 <code>promise</code> 的结果</p>\n<h4 id=\"新手错误2：forEach-循环-与-promise-如何兼得\"><a href=\"#新手错误2：forEach-循环-与-promise-如何兼得\" class=\"headerlink\" title=\"新手错误2：forEach()/循环 与 promise 如何兼得\"></a>新手错误2：<code>forEach()/循环</code> 与 <code>promise</code> 如何兼得</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我想通过 remove() 处理所有文档</span></span><br><span class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">\tresult.rows.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">rows</span>) </span>&#123;</span><br><span class=\"line\">\t\tdb.remove(row.doc);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 我认为所有文档都被移除了 ha?</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码有什么问题？问题在于，第一个 function 会返回 undefined，意味着第二个 function 不会等待所有文档都执行 db.remove()。实际上，它根本什么都不会等，任意数目的文档被移除时，第二个方法都会执行。</p>\n<p>解决的方法是，应该用 <code>Promise.all()</code> 来替代 <code>forEach()</code>/<code>for</code>/<code>while</code> 处理异步循环<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resp</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(result.rows.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">row</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> db.remove(row.doc);</span><br><span class=\"line\">\t&#125;));</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arrayOfResults</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 此时，所有文档才真正被移除</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这到底发生了什么？简单来说，<code>Promise.all()</code> 以一个包含多个 promise 的数组作为输入，返回另一个 promise 作为输出，只有当输入数组中的所有 promise 的状态都转变为 <code>resolved</code>，该输出的 promise 状态才会变成 <code>resolved</code>，相当于异步的for循环</p>\n<p><code>Promise.all()</code> 也会向随后的处理函数传递一个包含所有结果的数组，这是非常有用的，例如，试图通过 <code>get()</code> 从 PouchDB 中获取多个数据。如果输入数组中包含的 promise，有任意一个状态转变为 <code>rejected</code>，该 <code>all()</code>的 promise 都会变为 <code>rejected</code></p>\n<h4 id=\"新手错误3：忘记加上-catch\"><a href=\"#新手错误3：忘记加上-catch\" class=\"headerlink\" title=\"新手错误3：忘记加上 .catch()\"></a>新手错误3：忘记加上 <code>.catch()</code></h4><p>这是另一个常见的错误。简单的认为他们写的promise绝不会抛出错误，很多开发者都会忘记在 promise 链的末尾加上 <code>.catch()</code>。一旦如此，promise 中任何被抛出的错误都会被掩盖，甚至无法再 console 中展现，无疑会提高 debug 的难度</p>\n<p>为避免上述情况的发生，我建议在每一个promise链的末尾都加上 <code>.catch()</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> anotherPromise();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> yetAnotherPromise();</span><br><span class=\"line\">&#125;).catch(<span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>)); <span class=\"comment\">// &lt;-- this is badass</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"新手错误4：使用-deferred\"><a href=\"#新手错误4：使用-deferred\" class=\"headerlink\" title=\"新手错误4：使用 deferred\"></a>新手错误4：使用 <code>deferred</code></h4><p>我总是能看到这类<a href=\"http://gonehybrid.com/how-to-use-pouchdb-sqlite-for-local-storage-in-your-ionic-app/\" target=\"_blank\" rel=\"noopener\">错误</a>，以至于我现在都不愿意重复这个单词</p>\n<p>简而言之，promise有一段漫长且曲折的历史，JS社区花费了大量的时间来纠正期间的错误。在promise发展的早期，jQuery 和 Angular 都通过 “deferred” 来实现各自的 promise，而现如今都被 ES6 的 promise 所取代，例如Q、when、RSVP、Bluebird、Lie等库都实现了符合 promise/A+ 规范的 promise</p>\n<p>如何避免使用 deferred 呢？</p>\n<p>首先，绝大多数 promise 库都会为你引入第三方库实现的 promise 的方法。例如，Angular 中的 <code>$q</code> 模块允许你通过 <code>$q.when()</code> 来包裹不符合 <code>$q</code> 规范的 promise。所以，Angular 使用者可以这样包裹 PouchDB promises：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$q.when(db.put(doc)).then(<span class=\"comment\">/* ... */</span>); <span class=\"comment\">// &lt;-- 这就是你迫切需要的</span></span><br></pre></td></tr></table></figure>\n<p>另一个方法是使用<a href=\"https://blog.domenic.me/the-revealing-constructor-pattern/\" target=\"_blank\" rel=\"noopener\">revealing constructor pattern</a>来包裹非 promise 的API。例如，封装基于回调的API，比如说 Nodejs 中的 <code>fs.readFile()</code>，可以这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  fs.readFile(<span class=\"string\">'myfile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, file</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> reject(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resolve(file);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"新手错误5：使用副作用而不是返回\"><a href=\"#新手错误5：使用副作用而不是返回\" class=\"headerlink\" title=\"新手错误5：使用副作用而不是返回\"></a>新手错误5：使用副作用而不是返回</h4><p>以下代码有什么问题？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  someOtherPromise();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我希望 someOtherPromise() 已经是 resolved 状态了</span></span><br><span class=\"line\">  <span class=\"comment\">// 事实却告诉我，它不是</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>是时候来详细了解 promise 的各个要点了</p>\n<p>正如我之前所说，promise 的魔力在于它回馈我们之前的 <code>return</code> 和 <code>throw</code>。实际中是如何体现的呢？</p>\n<p>每一个 promise 都会为你提供一个 <code>then()</code> 方法（或者 <code>catch()</code>方法，<code>then(null, ...)</code> 的语法糖）。让我们进入 <code>then()</code> 函数的内部：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 现在是 then() 函数的内部</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>我们在 <code>then()</code> 函数内部可以做什么？有三件事是可以做的：</p>\n<ol>\n<li><p><code>return</code> 另一个 promise</p>\n</li>\n<li><p><code>return</code> 一个同步的值（或 <code>undefined</code>）</p>\n</li>\n<li><p><code>throw</code> 一个同步的 error</p>\n</li>\n</ol>\n<p>一旦你掌握其中的诀窍，你就解开了 promise 的魔术。让我们逐点分析：</p>\n<ol>\n<li><p>返回另一个 promise</p>\n<p>这个模式在 promise 相关文章中很常见，就像上面提到的“合成promise”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意此处，我返回了第二个 promise ——返回 <code>return</code> 是关键，如果没有 <code>return</code> ，<code>getUserAccountById()</code> 就只会产生副作用，第二个 then 的处理函数就只能接收到 <code>undefined</code> 而不是 <code>userAccount</code></p>\n</li>\n<li><p>返回一个同步的值（或 undefined）</p>\n<p>返回 <code>undefined</code> 通常来说是一个错误，但返回一个同步的值，却是一种将同步代码转换为 promise 风格代码的很酷的方式。例如，我们有一份用户的缓存数据，我们可以做什么呢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id]; <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id); <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这不是很酷么？第二个函数根本不用关心 <code>userAccount</code> 是同步获取的还是异步获取的，第一个函数也可以随意返回同步的值或者异步的值。</p>\n<p>不幸的是，有个麻烦的事实摆在眼前：无返回值的函数，严格来说，都会默认返回 <code>undefined</code> ，意味着当你打算返回某些东西的时候，很容易在不经意间就产生副作用</p>\n<p>出于这个原因，我的个人习惯是，总是在 <code>.then()</code> 函数内加上 <code>return</code> 或者 <code>throw</code> sth，我建议你也这样做</p>\n</li>\n<li><p>抛出同步的异常</p>\n<p>说到 <code>throw</code> ，这是 promise 可以变得更加令人敬畏之处。比如说我们希望能够抛出一个同步的异常以防用户登出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (user.isLoggedOut()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'user logged out!'</span>); <span class=\"comment\">// throwing a synchronous error!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inMemoryCache[user.id]; <span class=\"comment\">// returning a synchronous value!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id); <span class=\"comment\">// returning a promise!</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I got a user account!</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Boom, I got an error!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，如果用户登出，<code>catch()</code> 会捕获到一个同步的异常，并且如果任意一个 promise 变为 rejected 状态， <code>catch()</code> 会捕获到一个异步的异常。同样，<code>catch()</code> 函数无需关系捕获的异常是同步的还是异步的。</p>\n<p>这在开发过程中确定代码异常极其有效！举个例子，在 <code>then()</code> 函数内部任意一处，我们执行 <code>JSON.parse()</code> 操作，如果是 JSON 是无效的，则会抛出一个同步的异常。在回调中，该异常会被掩盖；但在 promise 中，我们可以在 <code>catch()</code> 中轻松处理捕获到的异常。</p>\n</li>\n</ol>\n<h3 id=\"进阶错误\"><a href=\"#进阶错误\" class=\"headerlink\" title=\"进阶错误\"></a>进阶错误</h3><p>既然你已经学到了可以让 promise 变得简单的单一技巧，不妨来看看一些边角案例，当然，编程总是会遇到边角案例</p>\n<p>之所以说这些案例是进阶的，是因为我发现那些已经相当擅长 promise 的程序员才犯这些错。如果想弄清楚文章开头提到的那个问题，我们就有必要研究清楚这些案例</p>\n<h4 id=\"进阶错误1：不知道-Promise-resolve\"><a href=\"#进阶错误1：不知道-Promise-resolve\" class=\"headerlink\" title=\"进阶错误1：不知道 Promise.resolve()\"></a>进阶错误1：不知道 <code>Promise.resolve()</code></h4><p>正如我在上面提到的，promise 非常擅长将同步代码封装为异步代码。然而，如果下面这段代码你敲得多了的话：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  resolve(someSynchronousValue);</span><br><span class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>);</span><br></pre></td></tr></table></figure>\n<p>你可以用 <code>Promise.resolve()</code> 来更简洁的表明这一点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(someSynchronousValue).then(<span class=\"comment\">/* ... */</span>);</span><br></pre></td></tr></table></figure>\n<p>这在捕获任何同步的异常上也极其有效，正因如此，我已经养成了几乎所有 promise 返回API方法的习惯，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somePromiseAPI</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    doSomethingThatMayThrow();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</span><br><span class=\"line\">  &#125;).then(<span class=\"comment\">/* ... */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>记住一点：任何可能同步抛出的代码，都可以在某处找到几乎不可能调试的隐藏的异常。如果你用 <code>Promise.solve()</code> 包裹一切同步代码，则你总是可以在之后通过 <code>catch()</code> 函数捕获异常</p>\n<p>相似的，你可以用 <code>Promise.reject()</code> 来返回一个状态立刻变为 <code>rejected</code> 的 promise 实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some awful error'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"进阶错误2：then-resolveHandler-catch-rejectHandler-并不全等于-then-resolveHandler-rejectHandler\"><a href=\"#进阶错误2：then-resolveHandler-catch-rejectHandler-并不全等于-then-resolveHandler-rejectHandler\" class=\"headerlink\" title=\"进阶错误2：then(resolveHandler).catch(rejectHandler) 并不全等于 then(resolveHandler, rejectHandler)\"></a>进阶错误2：<code>then(resolveHandler).catch(rejectHandler)</code> 并不全等于 <code>then(resolveHandler, rejectHandler)</code></h4><p>上面提到的 <code>catch()</code> 是语法糖，因此如下两个代码片段是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>然而，下面两段代码却不是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> someOtherPromise();</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你还在疑惑为何不等价，不妨设想当第一个函数抛出异常时：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I caught your error! :)</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// I didn't catch your error! :(</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>事实证明，当你使用 <code>then(resolveHandler, rejectHandler)</code> 格式时，如果 <code>resolveHandler</code> 自身抛出了异常，<code>rejectHandler</code> 是自然无法捕获到的</p>\n<p>为此，我自己的习惯是：从不使用 <code>then()</code> 函数的第二个参数，而是使用 <code>catch()</code>。例外则是，当我在写异步的<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a> 测试用例时，我会使用第二个参数来确保异常能够被抛出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'should throw an error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doSomethingThatThrows().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'I expected an error!'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    should.exist(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>说到测试，在测试 promise API时，<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"noopener\">Mocha</a> 和 <a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"noopener\">Chai</a> 是绝妙的组合。<a href=\"https://github.com/pouchdb/plugin-seed\" target=\"_blank\" rel=\"noopener\">pouchdb-plugin-seed</a>项目中有一些简单的 <a href=\"https://github.com/pouchdb/plugin-seed/blob/master/test/test.js\" target=\"_blank\" rel=\"noopener\">测试用例</a> 可以拿来练手</p>\n<h4 id=\"进阶错误3：promises-VS-promise-factories\"><a href=\"#进阶错误3：promises-VS-promise-factories\" class=\"headerlink\" title=\"进阶错误3：promises VS promise factories\"></a>进阶错误3：promises VS promise factories</h4><p>或许你想按顺序一个一个的处理一组 promise，处理的方式近似于 <code>Promise.all()</code> ，但其中的 promise 却不是并发执行的</p>\n<p>你可能简单的认为理想的代码是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promises</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  promise.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promise</span>) </span>&#123;</span><br><span class=\"line\">    result = result.then(promise);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，上述代码无法达到你预期的效果，传递给 <code>executeSequentially()</code> 的多个 promise 仍然会并发执行</p>\n<p>发生这种情况的原因是你根本不想操作 promise 的数组，根据 promise 规范，一旦创建了 promise，它就会开始执行，你真正想要的是 promise factories 的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promiseFactories</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  promiseFactories.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">promiseFactory</span>) </span>&#123;</span><br><span class=\"line\">    result = result.then(promiseFactory);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我知道你在想什么：“这个 Java 程序员到底是谁，为什么他在谈论 factories 呢？”promise factories 很简单，只是一个会返回一个 promise 实例的函数而已:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myPromiseFactory</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> somethingThatCreatesAPromise();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这管用么？管用！promise factory 只有被调用时才会生成 promise，它运行的方式类似于 <code>then</code> 函数——实际上，它们就是一回事</p>\n<p>观察上述的 <code>executeSequentially()</code> 函数，然后想象 <code>myPromiseFactory</code> 被替换进 <code>result.then(...)</code> 内部，之后豁然开朗，这时你才刚接触到 promise 的启蒙</p>\n<h4 id=\"进阶错误4：如果我想要两个-promise-实例的结果呢\"><a href=\"#进阶错误4：如果我想要两个-promise-实例的结果呢\" class=\"headerlink\" title=\"进阶错误4：如果我想要两个 promise 实例的结果呢\"></a>进阶错误4：如果我想要两个 promise 实例的结果呢</h4><p>通常，一个 promise 实例将取决于另一个 promise 实例，但如果想要获取这两个 promise 实例的输出呢？比如说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 槽糕，我也需要获取 user 对象啊！</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>既要当个优秀的JS程序员，又要避免“爆炸金字塔”的出现，我们或许应该将 <code>user</code> 对象存储在更高一级作用域的变量中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user;</span><br><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  user = result;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 好了，user 和 userAccount 都可以获取到了</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这办法能用，但只是凑合。我的建议是：放开先前的偏见，拥抱金字塔：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 你看，我也可以获取 user 和 userAccount </span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>至少，暂时的“拥抱金字塔”:)</p>\n<p>如果代码缩进变成了一个问题，那你可以做JS程序员“自古以来”一直在做的事——将函数提取到一个命名函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUserAndUserAccount</span>(<span class=\"params\">user, userAccount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doSomething(user, userAccount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUser</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">userAccount</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserByName(<span class=\"string\">'onlan'</span>)</span><br><span class=\"line\">\t.then(onGetUser)</span><br><span class=\"line\">\t.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 运行到这里时，doSomething() 已经执行完毕，我们的缩进归零了</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当你的 promise 代码越来越复杂时，你会发现你会将越来越多的函数提取到命名函数中，代码也会变得更加美观：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">putYourRightFootIn()</span><br><span class=\"line\">\t.then(putYourRightFootOut)</span><br><span class=\"line\">\t.then(putYourRightFootIn)</span><br><span class=\"line\">\t.then(shakeItAllAbout);</span><br></pre></td></tr></table></figure>\n<p>这就是 promise 出现的意义！</p>\n<h4 id=\"进阶错误5：promise-fall-through-通过\"><a href=\"#进阶错误5：promise-fall-through-通过\" class=\"headerlink\" title=\"进阶错误5：promise fall through 通过\"></a>进阶错误5：promise fall through 通过</h4><p>这是我在上面介绍 promise 时提到的错误，极其深奥的案例，或许永远都不会出现在你的代码里，但它着实让我吓了一跳</p>\n<p>看到如下代码你有什么想法么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>)).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>你可能觉得会打印 <code>bar</code>，但结果却是 <code>foo</code></p>\n<p>原因在于，当你向 <code>then()</code> 传递一个非函数（例如 promise 实例）时，它实际上会将其看作 <code>then(null)</code> ，这会导致前一个 promise 的结果通过。你不妨试试：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"literal\">null</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就算中间加上无数的 <code>then(null)</code>，打印的结果仍然是 <code>foo</code></p>\n<p>这实际上回到了之前关于 promise VS promise factories 的讨论。简单地说，你可以直接向 <code>then()</code> 方法中传入一个 promise 实例，但它却不会依照你希望的那样运行。<code>then()</code> 期望获取一个函数，所以大部分情况你的意思应该是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 结果是 bar，正如我们期望的</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>所以记住一点：给 <code>then()</code> 传入的只能是函数（不要传别的什么）！</p>\n<h3 id=\"答疑\"><a href=\"#答疑\" class=\"headerlink\" title=\"答疑\"></a>答疑</h3><h5 id=\"题目一\"><a href=\"#题目一\" class=\"headerlink\" title=\"题目一\"></a>题目一</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doSomethingElse();</span><br><span class=\"line\">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|-----------------|</span><br><span class=\"line\">                  doSomethingElse(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                  |------------------|</span><br><span class=\"line\">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class=\"line\">                                     |------------------|</span><br></pre></td></tr></table></figure>\n<h5 id=\"题目二\"><a href=\"#题目二\" class=\"headerlink\" title=\"题目二\"></a>题目二</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  doSomethingElse();</span><br><span class=\"line\">&#125;).then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|------------------|</span><br><span class=\"line\">                   doSomethingElse(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                   |------------------|</span><br><span class=\"line\">                   finalHandler(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                   |------------------|</span><br></pre></td></tr></table></figure>\n<h5 id=\"题目三\"><a href=\"#题目三\" class=\"headerlink\" title=\"题目三\"></a>题目三</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(doSomethingElse())</span><br><span class=\"line\">\t.then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|------------------|</span><br><span class=\"line\">doSomethingElse(<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">|---------------------------------|</span><br><span class=\"line\">                   finalHandler(resultOfDoSomething)</span><br><span class=\"line\">                   |------------------|</span><br></pre></td></tr></table></figure>\n<h5 id=\"题目四\"><a href=\"#题目四\" class=\"headerlink\" title=\"题目四\"></a>题目四</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(doSomethingElse)</span><br><span class=\"line\">\t.then(finalHandler);</span><br></pre></td></tr></table></figure>\n<p>答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething</span><br><span class=\"line\">|-----------------|</span><br><span class=\"line\">                  doSomethingElse(resultOfDoSomething)</span><br><span class=\"line\">                  |-----------------|</span><br><span class=\"line\">                                    finalHandler(resultOfDoSomethingElse)</span><br><span class=\"line\">                                    |-----------------|</span><br></pre></td></tr></table></figure>\n<p>如果还是不太明白这些答案，我建议你重新再把这篇文章看一遍，或者自己定义 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 这两个方法，放到浏览器里试试</p>\n<blockquote>\n<p>说明：这些给出的例子，我假定 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 都返回 promise，并且这些 promise 表示在 JavaScript 事件循环之外完成的事（例如 IndexedDB、network、setTimeout），这就是为什么在合适的情况下，它们显示成并发，<a href=\"http://jsbin.com/tuqukakawo/1/edit?js,console,output\" target=\"_blank\" rel=\"noopener\">演示</a></p>\n</blockquote>\n<p>promise 的更多进阶用法—— <a href=\"https://gist.github.com/nolanlawson/6ce81186421d2fa109a4\" target=\"_blank\" rel=\"noopener\">promise protips chear sheet</a></p>\n<h4 id=\"关于-promise-的最后几句话\"><a href=\"#关于-promise-的最后几句话\" class=\"headerlink\" title=\"关于 promise 的最后几句话\"></a>关于 promise 的最后几句话</h4><p>Promise 是伟大的，如果你仍然在使用回调（嵌套），我强烈建议你讲代码转换为 promise 风格，你的代码将变得更加紧凑、优雅、更具可读性</p>\n<p>不信？你看这个例子：<a href=\"https://t.co/hRyc6ENYGC\" target=\"_blank\" rel=\"noopener\">a refactor of PouchDB’s map/reduce module</a> 其中用 promise 取代回调，结果是：290个插入操作，555个删除操作</p>\n<p>顺带提一句，那个写出恶心的回调嵌套代码的人，其实是我自己，所以这也算是我在 promise 原初魔力的第一课，同时感谢其他 PouchDB 的贡献者一路对我的指导</p>\n<p>话虽如此，promise 并非完美，但就像是瘦死的骆驼比马大，promise 仍旧要好过回调，因此就目前而言，其中一个要比另一个更接近“完美”，但是如果你有机会选择更好的，那就要尽力避免它们俩</p>\n<p>虽然优于回调，promise 仍然难以理解且极易出错，正因如此我才写下这篇文章讲明其中事实。新手和专家都会经常混淆这些概念，真的，这不是他们的错，问题在于 promise ——虽然近似于我们在同步代码中使用的模式，看起来是个不错的替代品，但却不是百分之百相同</p>\n<p>实际上，你不应该学习一堆神秘的规则和新的 API 来做这些事，在同步的世界里，你可以完全使用你熟悉的模式，如 <code>return</code>、<code>catch</code>、<code>throw</code>和 <code>for</code> 循环。你的脑子里不应该始终有两套系统并行！</p>\n<h4 id=\"Awaiting-async-await\"><a href=\"#Awaiting-async-await\" class=\"headerlink\" title=\"Awaiting async/await\"></a>Awaiting async/await</h4><p>这是我另一篇文章 <a href=\"http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html\" target=\"_blank\" rel=\"noopener\">Taming the asynchronous beast with ES7</a> 中讨论的要点，其中我研究了 ES7 的关键字 <code>async</code>/<code>await</code>，以及它们如何将 promise 深层次的融合到 JS 这门语言中。相比于写伪同步代码（其中提供的 <code>catch()</code> 方法看似与 <code>catch</code> 一致，实则不然），ES7 允许我们使用真正的 <code>try</code>/<code>catch</code>/<code>return</code> 关键字，正如我们在 CS 101 里学到的那样</p>\n<p>就 JS 这门语言来说，这是一个巨大的福音。因为最终，只要工具不在我们犯错时及时提示，这些 promise 反模式就总是会不经意出现</p>\n<p>以 JS 的历史为例，我认为 <a href=\"http://jslint.com/\" target=\"_blank\" rel=\"noopener\">JSLint</a> 和 <a href=\"http://jshint.com/\" target=\"_blank\" rel=\"noopener\">JSHint</a> 对 JS 社区做出的贡献要比 <a href=\"http://amzn.com/0596517742\" target=\"_blank\" rel=\"noopener\">JS 语言精粹</a> 要多，即使它们有效的包含相同的信息。这就像是“明确指出你的代码中何处出错了”和“通过阅读一本书来试图搞清楚别人的代码是怎么出错的”的区别</p>\n<p>ES7 的 <code>async</code>/<code>await</code> 的美在于，在大多数情况下，代码中的错误会将自己显示为语法、编译器错误，而不是运行时的微妙的错误。不过，在那之前，熟悉并掌握 promise，以及如何在 ES5 和 ES6 中正确使用是一件好事</p>\n<p>但我却意识到一点，就像是《JS 语言精粹》这本书一样，这篇文章所能提供的影响是有限的。但当你看到他们犯同样的错误时，你完全有能力指出其中的错误，因为我们中有太多的人需要承认一点：我还并没有百分之百掌握 promise ！</p>\n<blockquote>\n<p>更新：需要指出的一点是：Bluebird 3.0 将会提供告警信息以避免我在本文中提到的许多错误。所以，在 ES7 完全推出之前，Bluebird 会是另一个非常不错的选择</p>\n</blockquote>\n<p><a href=\"https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n"},{"title":"[译]通过从头实现一个promise来学习promise","date":"2018-06-06T13:45:14.000Z","_content":"[原文地址：Learn JavaScript Promises by Building a Promise from Scratch\n](https://levelup.gitconnected.com/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720)\n\n---\n\n通过自建一个 `Promise` 逐步了解 `Promise` 的工作原理\n\n你以前可能见过类似下方的代码：\n\n```javascript\nfetch('/user/1')\n  .then((user) => {\n      /* Do something with user after the API returns */\n  })\n```\n\n`.then()` 中包裹的代码块在执行之前，会一直等待，直到接收到来自服务器的响应。这就叫做 `Promise`。但千万不要被这花名和其中的异步代码吓退——一个 `Promise` 只是一个很普通的旧的 `JavaScript` 对象，它具有特殊的方法，可以让你同步执行代码(即使有延迟，它也会按顺序执行)\n\n```javascript\ntypeof new Promise((resolve, reject) => {}) === 'object'\n// true\n```\n\n重申一遍(原作者语：我第一次学习 `promise` 时，我很难把握 `promise` 的要点)，`Promise` 只是一个对象。为了保证会等待服务器并在服务器返回响应后执行 `.then()` 方法链中的代码，你<b>必须</b>返回一个 `Promise` 对象。这跟某些开箱即用的函数是两码事。下面的例子中，`fetch` 函数就是这么个函数\n\n```javascript\nconst fetch = function(url) {\n    return new Promise((resolve, reject) => {\n        request((error, apiResponse) => {\n            if (error) {\n                reject(error)\n            }\n            \n            resolve(apiResponse)\n        })\n    })\n}\n```\n上述的 `fetch()` 函数向服务器发送一个 http 请求，但客户端并不知道服务器何时返回结果。所以，`JavaScript` 会在等待服务器返回结果期间，执行其他无关的代码，一旦客户端接收到服务器返回的响应，它就会通过调用 `resolve(apiResponse)` 开始执行 `.then()` 语句中的代码。\n\n---\n\n现在让我们仔细看看 `Promise` 到底是如何做到这一点的：\n\n```javascript\nclass PromiseSimple {\n    constructor(executionFunction) {\n        this.promiseChain = [];\n        this.handleError = () => {};\n        \n        this.onResolve = this.onResolve.bind(this)\n        this.onReject = this.onReject.bind(this)\n        \n        executionFunction(this.onResolve, this.onReject)\n    }\n    \n    then(onResolve) {\n        this.promiseChain.push(onResolve)\n    \t\n    \treturn this\n    }\n    \n    catch(handleError) {\n        this.handleError = handleError\n        \n        return this\n    }\n    \n    onResolve(value) {\n        let storedValue = value\n        \n        try {\n            this.promiseChain.forEach((nextFunction) => {\n                storedValue = nextFunction(storedValue)\n            })\n        } catch (error) {\n            this.promiseChain = [];\n            \n            this.onReject(error)\n        }\n    }\n    \n    onReject(error) {\n        this.handleError(error)\n    }\n}\n```\n\n> 注意：上述版本的 `Promise` 只是用了学习 `Promise` 工作原理的，省略了一些更高级的功能，只提炼了最核心的部分\n\n### 工作原理\n\n我将其命名为 `PromiseSimple` ，防止在 Chrome 控制台运行上述代码时，原生的 `Promise` 被覆盖。上述版本的 promise 实现有一个构造函数，两个公共方法(与原生的 `then()` 和 `catch()` 类似)，两个内置方法： `onResolve()` 和 `onReject()`\n\n\n1. 当你创建一个 promise 时，你会像这样创建： `new Promise((resolve, reject) => {/* ... */})`。你会在构造函数中向 promise 传递一个回调函数，我命名为 `executionFunction`。执行函数会携带 `resolve` 和 `reject` ，映射为内置的 `onResolve` 和 `onReject` 方法。这些方法都会在 `fetch` 调用 resolve 或 reject 时被调用。\n\n\n2. 构造函数也会创建一个 `promiseChain` 数组和 `handleError` 函数。当 promise 后面接了一串 `.then(() => {})` 时，它会将每一个函数添加到 `promiseChain` 中；当用户调用 `catch(() => {})` 时，它会将函数分配给内部的 `handleError`。注意，`then()` 和 `catch` 都有 `return this`，以便可以链式调用 `then()`\n\n> 注意：对原生的 `Promise` 而言，它的 `then()` 和 `catch()` 函数都会返回一个 `new Promise`，而上述简版 `Promise` 只是返回了 `this`。另外，多个 `.catch()` 也可以链式调用，不一定要接在 `.then()` 方法链的末尾\n\n\n3. 当你的异步代码调用了 `resolve(apiResponse)`，自建的 promise 对象便会开始执行 `onResolve(apiResponse)`：迭代整个 `promiseChain` ，取出队首的方法，传入 `storedValue` 中最近保存的值并执行，然后用最近执行的结果更新 `storedValue`。它会按顺序执行 `promiseChain` 中保存的函数，借此创建同步的 `promise` 链。\n\n\n4. 该循环（上述的迭代）被封装在 `try/catch` 块中，以便捕获运行时的错误。如果你的异步代码调用了 `reject(error)` 或者 `try/catch` 捕获了一个错误，它将被传递给 `onReject()` 方法，该方法调用作为参数传递给 `.catch()` 的回调函数。\n\n### promiseSimple with test example\n\n### 具体的实现及使用\n\n```javascript\nclass PromiseSimple {\n    constructor(executionFunction) {\n        this.promiseChain = [];\n        this.handleError = () => {}\n    \t\n    \tthis.onResolve = this.onResolve.bind(this)\n    \tthis.onReject = this.onReject.bind(this)\n    \n    \texecutionFunction(this.onResolve, this.onReject)\n    }\n    \n    then(onResolve) {\n        this.promiseChain.push(onResolve)\n        \n        return this\n    }\n    \n    catch(handleError) {\n        this.handleError = handleError\n        \n        return this\n    }\n    \n    onResolve(value) {\n        let storedValue = value\n        \n        try {\n            this.promiseChain.forEach((nextFunction) => {\n                storedValue = nextFunction(storedValue)\n            })\n        } catch (error) {\n            this.promiseChain = [];\n            \n            this.onReject(error)\n        }\n    }\n    \n    onReject(error) {\n        this.handleError(error)\n    }\n}\n\n// test example\nfakeApiBackend = () => {\n    const user = {\n        username: 'treyhuffine',\n        favoriteNumber: 42,\n        profile: 'https://gitconnected.com/treyhuffine'\n    }\n    \n    if (Math.random() > .05) {\n    \treturn {\n            data: user,\n            statusCode: 200\n    \t}\n    } else {\n        const error = {\n            statusCode: 404,\n            message: 'Could not find user',\n            error: 'Not Found'\n        }\n        \n        return error\n    }\n}\n\nconst makeApiCall = () => {\n    return new PromiseSimple((resolve, reject) => {\n        setTimeout(() => {\n            const apiResponse = fakeApiBackend()\n            \n            if (apiResponse.statusCode >= 400) {\n                reject(apiResponse)\n            } else {\n                resolve(apiResponse.data)\n            }\n        }, 5000)\n    })\n}\n\nmakeApiCall()\n\t.then((user) => {\n        console.log('In the first .then()')\n        \n        return user\n\t})\n\t.then((user) => {\n        console.log(`User ${user.username}'s favorite number is ${user.favoriteNumber}`)\n        \n        return user\n\t})\n\t.then((user) => {\n        console.log('The previous .then() told you the favoriteNumber')\n        \n        return user.profile\n\t})\n\t.then((profile) => {\n        console.log(`The profile URL is ${profile}`)\n\t})\n\t.then(() => {\n        console.log('This is the last then()')\n\t})\n\t.catch((error) => {\n        console.log(error.message)\n\t})\n```","source":"_posts/译-通过从头实现一个promise来学习promise.md","raw":"---\ntitle: '[译]通过从头实现一个promise来学习promise'\ndate: 2018-06-06 21:45:14\ntags:\n---\n[原文地址：Learn JavaScript Promises by Building a Promise from Scratch\n](https://levelup.gitconnected.com/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720)\n\n---\n\n通过自建一个 `Promise` 逐步了解 `Promise` 的工作原理\n\n你以前可能见过类似下方的代码：\n\n```javascript\nfetch('/user/1')\n  .then((user) => {\n      /* Do something with user after the API returns */\n  })\n```\n\n`.then()` 中包裹的代码块在执行之前，会一直等待，直到接收到来自服务器的响应。这就叫做 `Promise`。但千万不要被这花名和其中的异步代码吓退——一个 `Promise` 只是一个很普通的旧的 `JavaScript` 对象，它具有特殊的方法，可以让你同步执行代码(即使有延迟，它也会按顺序执行)\n\n```javascript\ntypeof new Promise((resolve, reject) => {}) === 'object'\n// true\n```\n\n重申一遍(原作者语：我第一次学习 `promise` 时，我很难把握 `promise` 的要点)，`Promise` 只是一个对象。为了保证会等待服务器并在服务器返回响应后执行 `.then()` 方法链中的代码，你<b>必须</b>返回一个 `Promise` 对象。这跟某些开箱即用的函数是两码事。下面的例子中，`fetch` 函数就是这么个函数\n\n```javascript\nconst fetch = function(url) {\n    return new Promise((resolve, reject) => {\n        request((error, apiResponse) => {\n            if (error) {\n                reject(error)\n            }\n            \n            resolve(apiResponse)\n        })\n    })\n}\n```\n上述的 `fetch()` 函数向服务器发送一个 http 请求，但客户端并不知道服务器何时返回结果。所以，`JavaScript` 会在等待服务器返回结果期间，执行其他无关的代码，一旦客户端接收到服务器返回的响应，它就会通过调用 `resolve(apiResponse)` 开始执行 `.then()` 语句中的代码。\n\n---\n\n现在让我们仔细看看 `Promise` 到底是如何做到这一点的：\n\n```javascript\nclass PromiseSimple {\n    constructor(executionFunction) {\n        this.promiseChain = [];\n        this.handleError = () => {};\n        \n        this.onResolve = this.onResolve.bind(this)\n        this.onReject = this.onReject.bind(this)\n        \n        executionFunction(this.onResolve, this.onReject)\n    }\n    \n    then(onResolve) {\n        this.promiseChain.push(onResolve)\n    \t\n    \treturn this\n    }\n    \n    catch(handleError) {\n        this.handleError = handleError\n        \n        return this\n    }\n    \n    onResolve(value) {\n        let storedValue = value\n        \n        try {\n            this.promiseChain.forEach((nextFunction) => {\n                storedValue = nextFunction(storedValue)\n            })\n        } catch (error) {\n            this.promiseChain = [];\n            \n            this.onReject(error)\n        }\n    }\n    \n    onReject(error) {\n        this.handleError(error)\n    }\n}\n```\n\n> 注意：上述版本的 `Promise` 只是用了学习 `Promise` 工作原理的，省略了一些更高级的功能，只提炼了最核心的部分\n\n### 工作原理\n\n我将其命名为 `PromiseSimple` ，防止在 Chrome 控制台运行上述代码时，原生的 `Promise` 被覆盖。上述版本的 promise 实现有一个构造函数，两个公共方法(与原生的 `then()` 和 `catch()` 类似)，两个内置方法： `onResolve()` 和 `onReject()`\n\n\n1. 当你创建一个 promise 时，你会像这样创建： `new Promise((resolve, reject) => {/* ... */})`。你会在构造函数中向 promise 传递一个回调函数，我命名为 `executionFunction`。执行函数会携带 `resolve` 和 `reject` ，映射为内置的 `onResolve` 和 `onReject` 方法。这些方法都会在 `fetch` 调用 resolve 或 reject 时被调用。\n\n\n2. 构造函数也会创建一个 `promiseChain` 数组和 `handleError` 函数。当 promise 后面接了一串 `.then(() => {})` 时，它会将每一个函数添加到 `promiseChain` 中；当用户调用 `catch(() => {})` 时，它会将函数分配给内部的 `handleError`。注意，`then()` 和 `catch` 都有 `return this`，以便可以链式调用 `then()`\n\n> 注意：对原生的 `Promise` 而言，它的 `then()` 和 `catch()` 函数都会返回一个 `new Promise`，而上述简版 `Promise` 只是返回了 `this`。另外，多个 `.catch()` 也可以链式调用，不一定要接在 `.then()` 方法链的末尾\n\n\n3. 当你的异步代码调用了 `resolve(apiResponse)`，自建的 promise 对象便会开始执行 `onResolve(apiResponse)`：迭代整个 `promiseChain` ，取出队首的方法，传入 `storedValue` 中最近保存的值并执行，然后用最近执行的结果更新 `storedValue`。它会按顺序执行 `promiseChain` 中保存的函数，借此创建同步的 `promise` 链。\n\n\n4. 该循环（上述的迭代）被封装在 `try/catch` 块中，以便捕获运行时的错误。如果你的异步代码调用了 `reject(error)` 或者 `try/catch` 捕获了一个错误，它将被传递给 `onReject()` 方法，该方法调用作为参数传递给 `.catch()` 的回调函数。\n\n### promiseSimple with test example\n\n### 具体的实现及使用\n\n```javascript\nclass PromiseSimple {\n    constructor(executionFunction) {\n        this.promiseChain = [];\n        this.handleError = () => {}\n    \t\n    \tthis.onResolve = this.onResolve.bind(this)\n    \tthis.onReject = this.onReject.bind(this)\n    \n    \texecutionFunction(this.onResolve, this.onReject)\n    }\n    \n    then(onResolve) {\n        this.promiseChain.push(onResolve)\n        \n        return this\n    }\n    \n    catch(handleError) {\n        this.handleError = handleError\n        \n        return this\n    }\n    \n    onResolve(value) {\n        let storedValue = value\n        \n        try {\n            this.promiseChain.forEach((nextFunction) => {\n                storedValue = nextFunction(storedValue)\n            })\n        } catch (error) {\n            this.promiseChain = [];\n            \n            this.onReject(error)\n        }\n    }\n    \n    onReject(error) {\n        this.handleError(error)\n    }\n}\n\n// test example\nfakeApiBackend = () => {\n    const user = {\n        username: 'treyhuffine',\n        favoriteNumber: 42,\n        profile: 'https://gitconnected.com/treyhuffine'\n    }\n    \n    if (Math.random() > .05) {\n    \treturn {\n            data: user,\n            statusCode: 200\n    \t}\n    } else {\n        const error = {\n            statusCode: 404,\n            message: 'Could not find user',\n            error: 'Not Found'\n        }\n        \n        return error\n    }\n}\n\nconst makeApiCall = () => {\n    return new PromiseSimple((resolve, reject) => {\n        setTimeout(() => {\n            const apiResponse = fakeApiBackend()\n            \n            if (apiResponse.statusCode >= 400) {\n                reject(apiResponse)\n            } else {\n                resolve(apiResponse.data)\n            }\n        }, 5000)\n    })\n}\n\nmakeApiCall()\n\t.then((user) => {\n        console.log('In the first .then()')\n        \n        return user\n\t})\n\t.then((user) => {\n        console.log(`User ${user.username}'s favorite number is ${user.favoriteNumber}`)\n        \n        return user\n\t})\n\t.then((user) => {\n        console.log('The previous .then() told you the favoriteNumber')\n        \n        return user.profile\n\t})\n\t.then((profile) => {\n        console.log(`The profile URL is ${profile}`)\n\t})\n\t.then(() => {\n        console.log('This is the last then()')\n\t})\n\t.catch((error) => {\n        console.log(error.message)\n\t})\n```","slug":"译-通过从头实现一个promise来学习promise","published":1,"updated":"2018-06-06T15:19:53.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sxw4xp0002gn4mfvr6g1p7","content":"<p><a href=\"https://levelup.gitconnected.com/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720\" target=\"_blank\" rel=\"noopener\">原文地址：Learn JavaScript Promises by Building a Promise from Scratch\n</a></p>\n<hr>\n<p>通过自建一个 <code>Promise</code> 逐步了解 <code>Promise</code> 的工作原理</p>\n<p>你以前可能见过类似下方的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'/user/1'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Do something with user after the API returns */</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p><code>.then()</code> 中包裹的代码块在执行之前，会一直等待，直到接收到来自服务器的响应。这就叫做 <code>Promise</code>。但千万不要被这花名和其中的异步代码吓退——一个 <code>Promise</code> 只是一个很普通的旧的 <code>JavaScript</code> 对象，它具有特殊的方法，可以让你同步执行代码(即使有延迟，它也会按顺序执行)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;&#125;) === <span class=\"string\">'object'</span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>重申一遍(原作者语：我第一次学习 <code>promise</code> 时，我很难把握 <code>promise</code> 的要点)，<code>Promise</code> 只是一个对象。为了保证会等待服务器并在服务器返回响应后执行 <code>.then()</code> 方法链中的代码，你<b>必须</b>返回一个 <code>Promise</code> 对象。这跟某些开箱即用的函数是两码事。下面的例子中，<code>fetch</code> 函数就是这么个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fetch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        request(<span class=\"function\">(<span class=\"params\">error, apiResponse</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">                reject(error)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            resolve(apiResponse)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述的 <code>fetch()</code> 函数向服务器发送一个 http 请求，但客户端并不知道服务器何时返回结果。所以，<code>JavaScript</code> 会在等待服务器返回结果期间，执行其他无关的代码，一旦客户端接收到服务器返回的响应，它就会通过调用 <code>resolve(apiResponse)</code> 开始执行 <code>.then()</code> 语句中的代码。</p>\n<hr>\n<p>现在让我们仔细看看 <code>Promise</code> 到底是如何做到这一点的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PromiseSimple</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(executionFunction) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.onResolve = <span class=\"keyword\">this</span>.onResolve.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.onReject = <span class=\"keyword\">this</span>.onReject.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        executionFunction(<span class=\"keyword\">this</span>.onResolve, <span class=\"keyword\">this</span>.onReject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    then(onResolve) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain.push(onResolve)</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(handleError) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = handleError</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onResolve(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> storedValue = value</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain.forEach(<span class=\"function\">(<span class=\"params\">nextFunction</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                storedValue = nextFunction(storedValue)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.onReject(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onReject(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：上述版本的 <code>Promise</code> 只是用了学习 <code>Promise</code> 工作原理的，省略了一些更高级的功能，只提炼了最核心的部分</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>我将其命名为 <code>PromiseSimple</code> ，防止在 Chrome 控制台运行上述代码时，原生的 <code>Promise</code> 被覆盖。上述版本的 promise 实现有一个构造函数，两个公共方法(与原生的 <code>then()</code> 和 <code>catch()</code> 类似)，两个内置方法： <code>onResolve()</code> 和 <code>onReject()</code></p>\n<ol>\n<li>当你创建一个 promise 时，你会像这样创建： <code>new Promise((resolve, reject) =&gt; {/* ... */})</code>。你会在构造函数中向 promise 传递一个回调函数，我命名为 <code>executionFunction</code>。执行函数会携带 <code>resolve</code> 和 <code>reject</code> ，映射为内置的 <code>onResolve</code> 和 <code>onReject</code> 方法。这些方法都会在 <code>fetch</code> 调用 resolve 或 reject 时被调用。</li>\n</ol>\n<ol start=\"2\">\n<li>构造函数也会创建一个 <code>promiseChain</code> 数组和 <code>handleError</code> 函数。当 promise 后面接了一串 <code>.then(() =&gt; {})</code> 时，它会将每一个函数添加到 <code>promiseChain</code> 中；当用户调用 <code>catch(() =&gt; {})</code> 时，它会将函数分配给内部的 <code>handleError</code>。注意，<code>then()</code> 和 <code>catch</code> 都有 <code>return this</code>，以便可以链式调用 <code>then()</code></li>\n</ol>\n<blockquote>\n<p>注意：对原生的 <code>Promise</code> 而言，它的 <code>then()</code> 和 <code>catch()</code> 函数都会返回一个 <code>new Promise</code>，而上述简版 <code>Promise</code> 只是返回了 <code>this</code>。另外，多个 <code>.catch()</code> 也可以链式调用，不一定要接在 <code>.then()</code> 方法链的末尾</p>\n</blockquote>\n<ol start=\"3\">\n<li>当你的异步代码调用了 <code>resolve(apiResponse)</code>，自建的 promise 对象便会开始执行 <code>onResolve(apiResponse)</code>：迭代整个 <code>promiseChain</code> ，取出队首的方法，传入 <code>storedValue</code> 中最近保存的值并执行，然后用最近执行的结果更新 <code>storedValue</code>。它会按顺序执行 <code>promiseChain</code> 中保存的函数，借此创建同步的 <code>promise</code> 链。</li>\n</ol>\n<ol start=\"4\">\n<li>该循环（上述的迭代）被封装在 <code>try/catch</code> 块中，以便捕获运行时的错误。如果你的异步代码调用了 <code>reject(error)</code> 或者 <code>try/catch</code> 捕获了一个错误，它将被传递给 <code>onReject()</code> 方法，该方法调用作为参数传递给 <code>.catch()</code> 的回调函数。</li>\n</ol>\n<h3 id=\"promiseSimple-with-test-example\"><a href=\"#promiseSimple-with-test-example\" class=\"headerlink\" title=\"promiseSimple with test example\"></a>promiseSimple with test example</h3><h3 id=\"具体的实现及使用\"><a href=\"#具体的实现及使用\" class=\"headerlink\" title=\"具体的实现及使用\"></a>具体的实现及使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PromiseSimple</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(executionFunction) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \t<span class=\"keyword\">this</span>.onResolve = <span class=\"keyword\">this</span>.onResolve.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    \t<span class=\"keyword\">this</span>.onReject = <span class=\"keyword\">this</span>.onReject.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    \texecutionFunction(<span class=\"keyword\">this</span>.onResolve, <span class=\"keyword\">this</span>.onReject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    then(onResolve) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain.push(onResolve)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(handleError) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = handleError</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onResolve(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> storedValue = value</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain.forEach(<span class=\"function\">(<span class=\"params\">nextFunction</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                storedValue = nextFunction(storedValue)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.onReject(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onReject(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test example</span></span><br><span class=\"line\">fakeApiBackend = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'treyhuffine'</span>,</span><br><span class=\"line\">        favoriteNumber: <span class=\"number\">42</span>,</span><br><span class=\"line\">        profile: <span class=\"string\">'https://gitconnected.com/treyhuffine'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">.05</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            data: user,</span><br><span class=\"line\">            statusCode: <span class=\"number\">200</span></span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> error = &#123;</span><br><span class=\"line\">            statusCode: <span class=\"number\">404</span>,</span><br><span class=\"line\">            message: <span class=\"string\">'Could not find user'</span>,</span><br><span class=\"line\">            error: <span class=\"string\">'Not Found'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> error</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> makeApiCall = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PromiseSimple(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> apiResponse = fakeApiBackend()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (apiResponse.statusCode &gt;= <span class=\"number\">400</span>) &#123;</span><br><span class=\"line\">                reject(apiResponse)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                resolve(apiResponse.data)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">5000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">makeApiCall()</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'In the first .then()'</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> user</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`User <span class=\"subst\">$&#123;user.username&#125;</span>'s favorite number is <span class=\"subst\">$&#123;user.favoriteNumber&#125;</span>`</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> user</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'The previous .then() told you the favoriteNumber'</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> user.profile</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">profile</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`The profile URL is <span class=\"subst\">$&#123;profile&#125;</span>`</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is the last then()'</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(error.message)</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://levelup.gitconnected.com/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720\" target=\"_blank\" rel=\"noopener\">原文地址：Learn JavaScript Promises by Building a Promise from Scratch\n</a></p>\n<hr>\n<p>通过自建一个 <code>Promise</code> 逐步了解 <code>Promise</code> 的工作原理</p>\n<p>你以前可能见过类似下方的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'/user/1'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Do something with user after the API returns */</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p><code>.then()</code> 中包裹的代码块在执行之前，会一直等待，直到接收到来自服务器的响应。这就叫做 <code>Promise</code>。但千万不要被这花名和其中的异步代码吓退——一个 <code>Promise</code> 只是一个很普通的旧的 <code>JavaScript</code> 对象，它具有特殊的方法，可以让你同步执行代码(即使有延迟，它也会按顺序执行)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;&#125;) === <span class=\"string\">'object'</span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>重申一遍(原作者语：我第一次学习 <code>promise</code> 时，我很难把握 <code>promise</code> 的要点)，<code>Promise</code> 只是一个对象。为了保证会等待服务器并在服务器返回响应后执行 <code>.then()</code> 方法链中的代码，你<b>必须</b>返回一个 <code>Promise</code> 对象。这跟某些开箱即用的函数是两码事。下面的例子中，<code>fetch</code> 函数就是这么个函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fetch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        request(<span class=\"function\">(<span class=\"params\">error, apiResponse</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">                reject(error)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            resolve(apiResponse)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述的 <code>fetch()</code> 函数向服务器发送一个 http 请求，但客户端并不知道服务器何时返回结果。所以，<code>JavaScript</code> 会在等待服务器返回结果期间，执行其他无关的代码，一旦客户端接收到服务器返回的响应，它就会通过调用 <code>resolve(apiResponse)</code> 开始执行 <code>.then()</code> 语句中的代码。</p>\n<hr>\n<p>现在让我们仔细看看 <code>Promise</code> 到底是如何做到这一点的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PromiseSimple</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(executionFunction) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.onResolve = <span class=\"keyword\">this</span>.onResolve.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.onReject = <span class=\"keyword\">this</span>.onReject.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        executionFunction(<span class=\"keyword\">this</span>.onResolve, <span class=\"keyword\">this</span>.onReject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    then(onResolve) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain.push(onResolve)</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(handleError) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = handleError</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onResolve(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> storedValue = value</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain.forEach(<span class=\"function\">(<span class=\"params\">nextFunction</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                storedValue = nextFunction(storedValue)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.onReject(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onReject(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：上述版本的 <code>Promise</code> 只是用了学习 <code>Promise</code> 工作原理的，省略了一些更高级的功能，只提炼了最核心的部分</p>\n</blockquote>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>我将其命名为 <code>PromiseSimple</code> ，防止在 Chrome 控制台运行上述代码时，原生的 <code>Promise</code> 被覆盖。上述版本的 promise 实现有一个构造函数，两个公共方法(与原生的 <code>then()</code> 和 <code>catch()</code> 类似)，两个内置方法： <code>onResolve()</code> 和 <code>onReject()</code></p>\n<ol>\n<li>当你创建一个 promise 时，你会像这样创建： <code>new Promise((resolve, reject) =&gt; {/* ... */})</code>。你会在构造函数中向 promise 传递一个回调函数，我命名为 <code>executionFunction</code>。执行函数会携带 <code>resolve</code> 和 <code>reject</code> ，映射为内置的 <code>onResolve</code> 和 <code>onReject</code> 方法。这些方法都会在 <code>fetch</code> 调用 resolve 或 reject 时被调用。</li>\n</ol>\n<ol start=\"2\">\n<li>构造函数也会创建一个 <code>promiseChain</code> 数组和 <code>handleError</code> 函数。当 promise 后面接了一串 <code>.then(() =&gt; {})</code> 时，它会将每一个函数添加到 <code>promiseChain</code> 中；当用户调用 <code>catch(() =&gt; {})</code> 时，它会将函数分配给内部的 <code>handleError</code>。注意，<code>then()</code> 和 <code>catch</code> 都有 <code>return this</code>，以便可以链式调用 <code>then()</code></li>\n</ol>\n<blockquote>\n<p>注意：对原生的 <code>Promise</code> 而言，它的 <code>then()</code> 和 <code>catch()</code> 函数都会返回一个 <code>new Promise</code>，而上述简版 <code>Promise</code> 只是返回了 <code>this</code>。另外，多个 <code>.catch()</code> 也可以链式调用，不一定要接在 <code>.then()</code> 方法链的末尾</p>\n</blockquote>\n<ol start=\"3\">\n<li>当你的异步代码调用了 <code>resolve(apiResponse)</code>，自建的 promise 对象便会开始执行 <code>onResolve(apiResponse)</code>：迭代整个 <code>promiseChain</code> ，取出队首的方法，传入 <code>storedValue</code> 中最近保存的值并执行，然后用最近执行的结果更新 <code>storedValue</code>。它会按顺序执行 <code>promiseChain</code> 中保存的函数，借此创建同步的 <code>promise</code> 链。</li>\n</ol>\n<ol start=\"4\">\n<li>该循环（上述的迭代）被封装在 <code>try/catch</code> 块中，以便捕获运行时的错误。如果你的异步代码调用了 <code>reject(error)</code> 或者 <code>try/catch</code> 捕获了一个错误，它将被传递给 <code>onReject()</code> 方法，该方法调用作为参数传递给 <code>.catch()</code> 的回调函数。</li>\n</ol>\n<h3 id=\"promiseSimple-with-test-example\"><a href=\"#promiseSimple-with-test-example\" class=\"headerlink\" title=\"promiseSimple with test example\"></a>promiseSimple with test example</h3><h3 id=\"具体的实现及使用\"><a href=\"#具体的实现及使用\" class=\"headerlink\" title=\"具体的实现及使用\"></a>具体的实现及使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PromiseSimple</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(executionFunction) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    \t</span><br><span class=\"line\">    \t<span class=\"keyword\">this</span>.onResolve = <span class=\"keyword\">this</span>.onResolve.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    \t<span class=\"keyword\">this</span>.onReject = <span class=\"keyword\">this</span>.onReject.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    \texecutionFunction(<span class=\"keyword\">this</span>.onResolve, <span class=\"keyword\">this</span>.onReject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    then(onResolve) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promiseChain.push(onResolve)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(handleError) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError = handleError</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onResolve(value) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> storedValue = value</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain.forEach(<span class=\"function\">(<span class=\"params\">nextFunction</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                storedValue = nextFunction(storedValue)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.promiseChain = [];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.onReject(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    onReject(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleError(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test example</span></span><br><span class=\"line\">fakeApiBackend = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'treyhuffine'</span>,</span><br><span class=\"line\">        favoriteNumber: <span class=\"number\">42</span>,</span><br><span class=\"line\">        profile: <span class=\"string\">'https://gitconnected.com/treyhuffine'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">.05</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            data: user,</span><br><span class=\"line\">            statusCode: <span class=\"number\">200</span></span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> error = &#123;</span><br><span class=\"line\">            statusCode: <span class=\"number\">404</span>,</span><br><span class=\"line\">            message: <span class=\"string\">'Could not find user'</span>,</span><br><span class=\"line\">            error: <span class=\"string\">'Not Found'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> error</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> makeApiCall = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PromiseSimple(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> apiResponse = fakeApiBackend()</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (apiResponse.statusCode &gt;= <span class=\"number\">400</span>) &#123;</span><br><span class=\"line\">                reject(apiResponse)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                resolve(apiResponse.data)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">5000</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">makeApiCall()</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'In the first .then()'</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> user</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`User <span class=\"subst\">$&#123;user.username&#125;</span>'s favorite number is <span class=\"subst\">$&#123;user.favoriteNumber&#125;</span>`</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> user</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'The previous .then() told you the favoriteNumber'</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> user.profile</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\">(<span class=\"params\">profile</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`The profile URL is <span class=\"subst\">$&#123;profile&#125;</span>`</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is the last then()'</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(error.message)</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"[译]Tasks,microtasks,queues,and schedules","date":"2018-07-01T08:47:20.000Z","_content":"\n> 当我告诉我的同事 [Matt Gaunt](https://twitter.com/gauntface) 我正打算写一篇关于 microtask 组织队列以及在浏览器事件循环中运行的文章时，他说“老实讲，Jake，打死我都不看”。好吧，不管怎样，文章嘛，写都写了╮(╯_╰)╭\n>\n> 实际上，如果你倾向于看视频，[Philip Roberts](https://twitter.com/philip_roberts) 在 JSConf 上关于 event loop 的[演讲](https://www.youtube.com/watch?v=8aGhZQkoFbQ)会是不错的选择——虽然没有提到 microtask，但是其余部分还是挺出彩的\n\n\n\n看看这段代码：\n\n```javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n});\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n```\n\n你觉得结果的打印顺序是什么？\n\n\n\n#### 小试牛刀\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/1-log-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe>\n正确答案是：\n\n`script start`、`script end`、`promise1`、`promise2`、`setTimeout`\n\n但就浏览器的支持来说，有些浏览器上打印的结果却有出入（备注：原文写于2015年）\n\nMicrosoft Edge、Firefox 40、iOS Safari 以及 桌面版 Safari 8.0.0 会在 `promise1` 和 `promise2` 前打印 `setTimeout`，尽管看起来像是一种罕见的情况（备注：原文为 a race condition 个人认为应该是 rare condition）。很奇怪，因为 Firefox 39 和 Safari 8.0.7 打印的结果是正常的\n\n\n\n#### 结果为什么会这样\n\n要想明白其中的原理，你需要搞清楚 event loop 是如何处理 task 和 microtask\n\n> 每一个“线程”都有自己的 **event loop** ，同样，每一个 web worker 也都有自己的 event loop，它们能独立运行，但同时，同源下的所有窗口共享一个 event loop 以便能够同步的交流。Event loop 不停地运行，执行队列里的每一个 task。一个 event loop 会有多个 task source(任务源)，以此保证每个源下的 task 的执行顺序（例如 [IndexedDB](https://w3c.github.io/IndexedDB/#database-access-task-source) 定义了自己的源），但浏览器会在每一轮循环里挑选源来获取要执行的 task。这使得浏览器能够给那些性能敏感（performance sensitive）的 task 给予优先权，例如 用户输入\n\n> 任务（task）会被编排（schedule）好，以便浏览器可以从其内部进入 JavaScript/DOM 领域并保证这些操作按顺序发生。从获取鼠标的单击事件到事件回调需要编排一个 task，同样的还有解析 HTML 以及上面提到的例子—— `setTimeout`\n\n`setTimeout` 会在给定的延迟内等待，然后给它自己的回调编排一个新的 task ——这就是为什么 `setTimeout` 会在 `script end` 后面打印了—— `script end` 是第一个 task 的一部分，而 `setTimeout` 是在另一个隔离的 task 内打印的。\n\n> 微任务（microtask）通常被编排用于那些在当前正在执行的脚本后直接发生的事物，例如对一组批量操作作出反应，或者不需要通过创建一个额外的、完整的任务（task）来获取异步的结果。只要没有其他 JavaScript 处于执行中期，并且处于每个任务（task）的末尾时，微任务队列（microtask queue）就会在回调后处理。在微任务队列中任何编排的其他微任务都会被添加到队列的末尾并进行处理。微任务包括 mutation observer callbacks 以及上面例子中的 promise callback\n\n一个 promise 实例的状态一旦变为凝滞，或者已经处于凝滞，它就会为其反应的回调向微任务队列中添加一个微任务——如此可以保证即使 promise 的状态已经凝滞，promise callback 一定是异步的。\n\n因此调用一个紧挨着状态凝滞的 promise 的 `then(yey, nay)` 会立即编排一个微任务——这就是 `promise1` 和 `promise2` 会在 `script end` 之后打印的原因——当前运行的脚本一定会在微任务执行前结束；而 `promise1` 和 `promise2` 出现在 `setTimeout` 之前，是因为（当前任务的）微任务总是发生在下一个任务之前。\n\n\n\n好吧，一步一步来：\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/2-step-test.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>\n##### 为什么部分浏览器执行的结果会有差异\n\n部分浏览器打印的结果是：`script start`、`script end`、`setTimeout`、`promise1`、`promise2`，从结果来看，它们会在 `setTimeout` 后面执行 promise 的回调——很有可能是因为它们将调用 promise 的回调当做新任务的一部分而不是微任务。\n\n这是可以理解的，因为 promise 来源于 ECMAScript 而不是 HTML:)\n\nECMAScript 中有“作业（job）”的概念，这类似于微任务，但除了 [vague mailing list duscussions](https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16) ，这两个概念的区别不是很明确。但普遍的共识是：有充足的理由要求我们将 promise 当做微任务队列的一部分\n\n将 promise 视为任务会导致性能问题，因为其回调可能会因与渲染等与任务相关的事务而不必要的延迟，它还会因与其他任务源的交互而导致非确定性，并且可能会破坏与其他 API 的交互，后面会对这个展开叙述\n\n[Edge正尝试在 promise 中使用 microtask](https://connect.microsoft.com/IE/feedback/details/1658365) （2015版 Edge，现在的 Edge 是基于 chrome 内核的），webkit nightly 一直都是这么做的，Firefox 43 也已经修复了这一点，所以我猜 Safari 最终也会选择修复这点\n\n\n\n#### 如何判断用的是 task 还是 microtask\n\n测试是一种方法。see when logs appear relative to promises & setTimeout，尽管你依赖于正确的实现（代码实现正确为前提，观察打印的结果，剖析 promise 以及 setTimeout 表现出的关系）\n\n查看规范也是一种方法。比如说，[`setTimeout` 的第14步](https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps) 会编排一个任务，而 [queue a mutation record 的第5步](https://dom.spec.whatwg.org/#queue-a-mutation-record) 会编排一个微任务\n\n如上所述，在 ECMAScript 领域，microtask 被称为“作业（job）”。在 [PerformPromiseThen 的第8步](https://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen) 中，`EnqueueJob` 会被调用去编排一个微任务\n\n\n\n好吧，试试更复杂的例子吧\n\n#### 第一关\n\n在写这边文章之前，我弄错了一点。看看下面的代码片段：\n\n```html\n<div class=\"outer\">\n  <div class=\"inner\"></div>\n</div>\n```\n\n给出以下 JS，如果我点击 `div.inner`，打印的结果是什么？\n\n```javascript\n// Let's get hold of those elements\nvar outer = document.querySelector('.outer');\nvar inner = document.querySelector('.inner');\n\n// Let;s listen for attribute changes on the\n// outer element\nnew MutationObserver(function() {\n  console.log('mutate');\n}).observe(outer, {\n  attributes: true\n});\n\n// Here's a click listener...\nfunction onClick() {\n  console.log('click');\n\t\n  setTimeout(function() {\n    console.log('timeout');\n  }, 0);\n  \n  Promise.resolve().then(function() {\n    console.log('promise');\n  });\n  \n  outer.setAttribute('data-random', Math.random());\n}\n\n// ...which we'll attach to both elements\ninner.addEventListener('click', onClick);\nouter.addEventListener('click', onClick);\n```\n\n在揭示答案之前可以用上述代码写个例子放到浏览器中测试——提示：打印会发生不止一次\n\n\n\n#### 测试\n\n点击内部的方块触发点击事件\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/3-square-click.html\" height=\"450\" width=\"600\" style=\"border: none;\"></iframe>\n\n与你的猜测有出入？如果有出入，你仍有可能是对的，毕竟浏览器之间是有差异的：\n\n\n\n\n\n#### 到底谁是对的\n\n派发 click 事件是一个任务；Mutation observer 以及 promise callbacks 会被编排为微任务；`setTimeout` 的回调会被编排为一个任务——以下便是代码运行的详细步骤：\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/4-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>\n\nChrome 里运行的结果是正确的。对我来说比较“新”的一点是微任务会在回调之后处理（只要没有其他 JavaScript 在执行中），我认为它是限于任务的末尾——这一规则来源于 HTML 规范中调用回调：\n\n> If the [stack of script settings objects](https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects) is now empty, [perform a microtask checkpoint](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)\n>\n> -- [HTML: Cleaning up after a callback](https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback) step 3 \n\n并且微任务检查点涉及遍历微任务队列，除非我们已经在处理微任务队列。类似的，ECMAScript 是这样描述作业的：\n\n> 仅当不存在正在运行的执行上下文，并且执行上下文的栈是空时，作业的执行**可以**被初始化\n>\n> —— ECMAScript: Jobs and Job Queues\n\n尽管 ECMAScript 中作业的“可以”变成了 HTML 上下文中的“必须”\n\n\n\n#### 浏览器出了什么问题？\n\n正如 mutation callbacks 所示，**Firefox** 和 **Safari** 能够正常处理点击监听之间的微任务队列，但对 promise 的编排却有不同。这是可以理解的，毕竟作业与微任务之间的联系是模糊的，但我仍然希望他们能在 listener callbacks 之间执行。[Firefox ticket](https://bugzilla.mozilla.org/show_bug.cgi?id=1193394)、[Safari ticket](https://bugs.webkit.org/show_bug.cgi?id=147933)\n\n至于 **Edge**，我们观察到它不仅不能正常编排 promise，也无法正常的处理点击监听之间的微任务队列，反而在调用所有监听器过后很久才会去处理微任务队列，因此表现为在两次click打印之后才记录到单个的mutate log。[Bug ticket](https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners)\n\n\n\n#### 第一关升级版\n\n同样的例子，如果我们执行下面这段代码，会发生什么？\n\n```javascript\ninner.click();\n```\n\n这会像先前那样开始事件派发，但不是通过现实的交互而是脚本触发\n\n\n\n#### 小试牛刀\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/5-click-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe>\n\n各个浏览器的结果：\n\n\n\n我坚信我会在 Chrome 一直获取不同的结果，这张图我已经更新过无数次，我曾一度以为我错误的测试了 Canary（Chrome开发版）\n\n\n\n#### 为什么Chrome的结果会不确定\n\n请看执行的步骤：\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/6-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>","source":"_posts/译-Tasks-microtasks-queues-and-schedules.md","raw":"---\ntitle: '[译]Tasks,microtasks,queues,and schedules'\ndate: 2018-07-01 16:47:20\ntags:\n---\n\n> 当我告诉我的同事 [Matt Gaunt](https://twitter.com/gauntface) 我正打算写一篇关于 microtask 组织队列以及在浏览器事件循环中运行的文章时，他说“老实讲，Jake，打死我都不看”。好吧，不管怎样，文章嘛，写都写了╮(╯_╰)╭\n>\n> 实际上，如果你倾向于看视频，[Philip Roberts](https://twitter.com/philip_roberts) 在 JSConf 上关于 event loop 的[演讲](https://www.youtube.com/watch?v=8aGhZQkoFbQ)会是不错的选择——虽然没有提到 microtask，但是其余部分还是挺出彩的\n\n\n\n看看这段代码：\n\n```javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n});\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n```\n\n你觉得结果的打印顺序是什么？\n\n\n\n#### 小试牛刀\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/1-log-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe>\n正确答案是：\n\n`script start`、`script end`、`promise1`、`promise2`、`setTimeout`\n\n但就浏览器的支持来说，有些浏览器上打印的结果却有出入（备注：原文写于2015年）\n\nMicrosoft Edge、Firefox 40、iOS Safari 以及 桌面版 Safari 8.0.0 会在 `promise1` 和 `promise2` 前打印 `setTimeout`，尽管看起来像是一种罕见的情况（备注：原文为 a race condition 个人认为应该是 rare condition）。很奇怪，因为 Firefox 39 和 Safari 8.0.7 打印的结果是正常的\n\n\n\n#### 结果为什么会这样\n\n要想明白其中的原理，你需要搞清楚 event loop 是如何处理 task 和 microtask\n\n> 每一个“线程”都有自己的 **event loop** ，同样，每一个 web worker 也都有自己的 event loop，它们能独立运行，但同时，同源下的所有窗口共享一个 event loop 以便能够同步的交流。Event loop 不停地运行，执行队列里的每一个 task。一个 event loop 会有多个 task source(任务源)，以此保证每个源下的 task 的执行顺序（例如 [IndexedDB](https://w3c.github.io/IndexedDB/#database-access-task-source) 定义了自己的源），但浏览器会在每一轮循环里挑选源来获取要执行的 task。这使得浏览器能够给那些性能敏感（performance sensitive）的 task 给予优先权，例如 用户输入\n\n> 任务（task）会被编排（schedule）好，以便浏览器可以从其内部进入 JavaScript/DOM 领域并保证这些操作按顺序发生。从获取鼠标的单击事件到事件回调需要编排一个 task，同样的还有解析 HTML 以及上面提到的例子—— `setTimeout`\n\n`setTimeout` 会在给定的延迟内等待，然后给它自己的回调编排一个新的 task ——这就是为什么 `setTimeout` 会在 `script end` 后面打印了—— `script end` 是第一个 task 的一部分，而 `setTimeout` 是在另一个隔离的 task 内打印的。\n\n> 微任务（microtask）通常被编排用于那些在当前正在执行的脚本后直接发生的事物，例如对一组批量操作作出反应，或者不需要通过创建一个额外的、完整的任务（task）来获取异步的结果。只要没有其他 JavaScript 处于执行中期，并且处于每个任务（task）的末尾时，微任务队列（microtask queue）就会在回调后处理。在微任务队列中任何编排的其他微任务都会被添加到队列的末尾并进行处理。微任务包括 mutation observer callbacks 以及上面例子中的 promise callback\n\n一个 promise 实例的状态一旦变为凝滞，或者已经处于凝滞，它就会为其反应的回调向微任务队列中添加一个微任务——如此可以保证即使 promise 的状态已经凝滞，promise callback 一定是异步的。\n\n因此调用一个紧挨着状态凝滞的 promise 的 `then(yey, nay)` 会立即编排一个微任务——这就是 `promise1` 和 `promise2` 会在 `script end` 之后打印的原因——当前运行的脚本一定会在微任务执行前结束；而 `promise1` 和 `promise2` 出现在 `setTimeout` 之前，是因为（当前任务的）微任务总是发生在下一个任务之前。\n\n\n\n好吧，一步一步来：\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/2-step-test.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>\n##### 为什么部分浏览器执行的结果会有差异\n\n部分浏览器打印的结果是：`script start`、`script end`、`setTimeout`、`promise1`、`promise2`，从结果来看，它们会在 `setTimeout` 后面执行 promise 的回调——很有可能是因为它们将调用 promise 的回调当做新任务的一部分而不是微任务。\n\n这是可以理解的，因为 promise 来源于 ECMAScript 而不是 HTML:)\n\nECMAScript 中有“作业（job）”的概念，这类似于微任务，但除了 [vague mailing list duscussions](https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16) ，这两个概念的区别不是很明确。但普遍的共识是：有充足的理由要求我们将 promise 当做微任务队列的一部分\n\n将 promise 视为任务会导致性能问题，因为其回调可能会因与渲染等与任务相关的事务而不必要的延迟，它还会因与其他任务源的交互而导致非确定性，并且可能会破坏与其他 API 的交互，后面会对这个展开叙述\n\n[Edge正尝试在 promise 中使用 microtask](https://connect.microsoft.com/IE/feedback/details/1658365) （2015版 Edge，现在的 Edge 是基于 chrome 内核的），webkit nightly 一直都是这么做的，Firefox 43 也已经修复了这一点，所以我猜 Safari 最终也会选择修复这点\n\n\n\n#### 如何判断用的是 task 还是 microtask\n\n测试是一种方法。see when logs appear relative to promises & setTimeout，尽管你依赖于正确的实现（代码实现正确为前提，观察打印的结果，剖析 promise 以及 setTimeout 表现出的关系）\n\n查看规范也是一种方法。比如说，[`setTimeout` 的第14步](https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps) 会编排一个任务，而 [queue a mutation record 的第5步](https://dom.spec.whatwg.org/#queue-a-mutation-record) 会编排一个微任务\n\n如上所述，在 ECMAScript 领域，microtask 被称为“作业（job）”。在 [PerformPromiseThen 的第8步](https://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen) 中，`EnqueueJob` 会被调用去编排一个微任务\n\n\n\n好吧，试试更复杂的例子吧\n\n#### 第一关\n\n在写这边文章之前，我弄错了一点。看看下面的代码片段：\n\n```html\n<div class=\"outer\">\n  <div class=\"inner\"></div>\n</div>\n```\n\n给出以下 JS，如果我点击 `div.inner`，打印的结果是什么？\n\n```javascript\n// Let's get hold of those elements\nvar outer = document.querySelector('.outer');\nvar inner = document.querySelector('.inner');\n\n// Let;s listen for attribute changes on the\n// outer element\nnew MutationObserver(function() {\n  console.log('mutate');\n}).observe(outer, {\n  attributes: true\n});\n\n// Here's a click listener...\nfunction onClick() {\n  console.log('click');\n\t\n  setTimeout(function() {\n    console.log('timeout');\n  }, 0);\n  \n  Promise.resolve().then(function() {\n    console.log('promise');\n  });\n  \n  outer.setAttribute('data-random', Math.random());\n}\n\n// ...which we'll attach to both elements\ninner.addEventListener('click', onClick);\nouter.addEventListener('click', onClick);\n```\n\n在揭示答案之前可以用上述代码写个例子放到浏览器中测试——提示：打印会发生不止一次\n\n\n\n#### 测试\n\n点击内部的方块触发点击事件\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/3-square-click.html\" height=\"450\" width=\"600\" style=\"border: none;\"></iframe>\n\n与你的猜测有出入？如果有出入，你仍有可能是对的，毕竟浏览器之间是有差异的：\n\n\n\n\n\n#### 到底谁是对的\n\n派发 click 事件是一个任务；Mutation observer 以及 promise callbacks 会被编排为微任务；`setTimeout` 的回调会被编排为一个任务——以下便是代码运行的详细步骤：\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/4-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>\n\nChrome 里运行的结果是正确的。对我来说比较“新”的一点是微任务会在回调之后处理（只要没有其他 JavaScript 在执行中），我认为它是限于任务的末尾——这一规则来源于 HTML 规范中调用回调：\n\n> If the [stack of script settings objects](https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects) is now empty, [perform a microtask checkpoint](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)\n>\n> -- [HTML: Cleaning up after a callback](https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback) step 3 \n\n并且微任务检查点涉及遍历微任务队列，除非我们已经在处理微任务队列。类似的，ECMAScript 是这样描述作业的：\n\n> 仅当不存在正在运行的执行上下文，并且执行上下文的栈是空时，作业的执行**可以**被初始化\n>\n> —— ECMAScript: Jobs and Job Queues\n\n尽管 ECMAScript 中作业的“可以”变成了 HTML 上下文中的“必须”\n\n\n\n#### 浏览器出了什么问题？\n\n正如 mutation callbacks 所示，**Firefox** 和 **Safari** 能够正常处理点击监听之间的微任务队列，但对 promise 的编排却有不同。这是可以理解的，毕竟作业与微任务之间的联系是模糊的，但我仍然希望他们能在 listener callbacks 之间执行。[Firefox ticket](https://bugzilla.mozilla.org/show_bug.cgi?id=1193394)、[Safari ticket](https://bugs.webkit.org/show_bug.cgi?id=147933)\n\n至于 **Edge**，我们观察到它不仅不能正常编排 promise，也无法正常的处理点击监听之间的微任务队列，反而在调用所有监听器过后很久才会去处理微任务队列，因此表现为在两次click打印之后才记录到单个的mutate log。[Bug ticket](https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners)\n\n\n\n#### 第一关升级版\n\n同样的例子，如果我们执行下面这段代码，会发生什么？\n\n```javascript\ninner.click();\n```\n\n这会像先前那样开始事件派发，但不是通过现实的交互而是脚本触发\n\n\n\n#### 小试牛刀\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/5-click-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe>\n\n各个浏览器的结果：\n\n\n\n我坚信我会在 Chrome 一直获取不同的结果，这张图我已经更新过无数次，我曾一度以为我错误的测试了 Canary（Chrome开发版）\n\n\n\n#### 为什么Chrome的结果会不确定\n\n请看执行的步骤：\n\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/6-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>","slug":"译-Tasks-microtasks-queues-and-schedules","published":1,"updated":"2019-10-16T07:08:36.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1sxw4xr0003gn4m6wg5brem","content":"<blockquote>\n<p>当我告诉我的同事 <a href=\"https://twitter.com/gauntface\" target=\"_blank\" rel=\"noopener\">Matt Gaunt</a> 我正打算写一篇关于 microtask 组织队列以及在浏览器事件循环中运行的文章时，他说“老实讲，Jake，打死我都不看”。好吧，不管怎样，文章嘛，写都写了╮(╯_╰)╭</p>\n<p>实际上，如果你倾向于看视频，<a href=\"https://twitter.com/philip_roberts\" target=\"_blank\" rel=\"noopener\">Philip Roberts</a> 在 JSConf 上关于 event loop 的<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\" target=\"_blank\" rel=\"noopener\">演讲</a>会是不错的选择——虽然没有提到 microtask，但是其余部分还是挺出彩的</p>\n</blockquote>\n<p>看看这段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br></pre></td></tr></table></figure>\n<p>你觉得结果的打印顺序是什么？</p>\n<h4 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h4><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/1-log-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe><br>正确答案是：<br><br><code>script start</code>、<code>script end</code>、<code>promise1</code>、<code>promise2</code>、<code>setTimeout</code><br><br>但就浏览器的支持来说，有些浏览器上打印的结果却有出入（备注：原文写于2015年）<br><br>Microsoft Edge、Firefox 40、iOS Safari 以及 桌面版 Safari 8.0.0 会在 <code>promise1</code> 和 <code>promise2</code> 前打印 <code>setTimeout</code>，尽管看起来像是一种罕见的情况（备注：原文为 a race condition 个人认为应该是 rare condition）。很奇怪，因为 Firefox 39 和 Safari 8.0.7 打印的结果是正常的<br><br><br><br>#### 结果为什么会这样<br><br>要想明白其中的原理，你需要搞清楚 event loop 是如何处理 task 和 microtask<br><br>&gt; 每一个“线程”都有自己的 <strong>event loop</strong> ，同样，每一个 web worker 也都有自己的 event loop，它们能独立运行，但同时，同源下的所有窗口共享一个 event loop 以便能够同步的交流。Event loop 不停地运行，执行队列里的每一个 task。一个 event loop 会有多个 task source(任务源)，以此保证每个源下的 task 的执行顺序（例如 <a href=\"https://w3c.github.io/IndexedDB/#database-access-task-source\" target=\"_blank\" rel=\"noopener\">IndexedDB</a> 定义了自己的源），但浏览器会在每一轮循环里挑选源来获取要执行的 task。这使得浏览器能够给那些性能敏感（performance sensitive）的 task 给予优先权，例如 用户输入<br><br>&gt; 任务（task）会被编排（schedule）好，以便浏览器可以从其内部进入 JavaScript/DOM 领域并保证这些操作按顺序发生。从获取鼠标的单击事件到事件回调需要编排一个 task，同样的还有解析 HTML 以及上面提到的例子—— <code>setTimeout</code><br><br><code>setTimeout</code> 会在给定的延迟内等待，然后给它自己的回调编排一个新的 task ——这就是为什么 <code>setTimeout</code> 会在 <code>script end</code> 后面打印了—— <code>script end</code> 是第一个 task 的一部分，而 <code>setTimeout</code> 是在另一个隔离的 task 内打印的。<br><br>&gt; 微任务（microtask）通常被编排用于那些在当前正在执行的脚本后直接发生的事物，例如对一组批量操作作出反应，或者不需要通过创建一个额外的、完整的任务（task）来获取异步的结果。只要没有其他 JavaScript 处于执行中期，并且处于每个任务（task）的末尾时，微任务队列（microtask queue）就会在回调后处理。在微任务队列中任何编排的其他微任务都会被添加到队列的末尾并进行处理。微任务包括 mutation observer callbacks 以及上面例子中的 promise callback<br><br>一个 promise 实例的状态一旦变为凝滞，或者已经处于凝滞，它就会为其反应的回调向微任务队列中添加一个微任务——如此可以保证即使 promise 的状态已经凝滞，promise callback 一定是异步的。<br><br>因此调用一个紧挨着状态凝滞的 promise 的 <code>then(yey, nay)</code> 会立即编排一个微任务——这就是 <code>promise1</code> 和 <code>promise2</code> 会在 <code>script end</code> 之后打印的原因——当前运行的脚本一定会在微任务执行前结束；而 <code>promise1</code> 和 <code>promise2</code> 出现在 <code>setTimeout</code> 之前，是因为（当前任务的）微任务总是发生在下一个任务之前。<br><br><br><br>好吧，一步一步来：<br><br><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/2-step-test.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe><br>##### 为什么部分浏览器执行的结果会有差异<br><br>部分浏览器打印的结果是：<code>script start</code>、<code>script end</code>、<code>setTimeout</code>、<code>promise1</code>、<code>promise2</code>，从结果来看，它们会在 <code>setTimeout</code> 后面执行 promise 的回调——很有可能是因为它们将调用 promise 的回调当做新任务的一部分而不是微任务。<br><br>这是可以理解的，因为 promise 来源于 ECMAScript 而不是 HTML:)<br><br>ECMAScript 中有“作业（job）”的概念，这类似于微任务，但除了 <a href=\"https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16\" target=\"_blank\" rel=\"noopener\">vague mailing list duscussions</a> ，这两个概念的区别不是很明确。但普遍的共识是：有充足的理由要求我们将 promise 当做微任务队列的一部分<br><br>将 promise 视为任务会导致性能问题，因为其回调可能会因与渲染等与任务相关的事务而不必要的延迟，它还会因与其他任务源的交互而导致非确定性，并且可能会破坏与其他 API 的交互，后面会对这个展开叙述<br><br><a href=\"https://connect.microsoft.com/IE/feedback/details/1658365\" target=\"_blank\" rel=\"noopener\">Edge正尝试在 promise 中使用 microtask</a> （2015版 Edge，现在的 Edge 是基于 chrome 内核的），webkit nightly 一直都是这么做的，Firefox 43 也已经修复了这一点，所以我猜 Safari 最终也会选择修复这点<br><br><br><br>#### 如何判断用的是 task 还是 microtask<br><br>测试是一种方法。see when logs appear relative to promises &amp; setTimeout，尽管你依赖于正确的实现（代码实现正确为前提，观察打印的结果，剖析 promise 以及 setTimeout 表现出的关系）<br><br>查看规范也是一种方法。比如说，<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps\" target=\"_blank\" rel=\"noopener\"><code>setTimeout</code> 的第14步</a> 会编排一个任务，而 <a href=\"https://dom.spec.whatwg.org/#queue-a-mutation-record\" target=\"_blank\" rel=\"noopener\">queue a mutation record 的第5步</a> 会编排一个微任务<br><br>如上所述，在 ECMAScript 领域，microtask 被称为“作业（job）”。在 <a href=\"https://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen\" target=\"_blank\" rel=\"noopener\">PerformPromiseThen 的第8步</a> 中，<code>EnqueueJob</code> 会被调用去编排一个微任务<br><br><br><br>好吧，试试更复杂的例子吧<br><br>#### 第一关<br><br>在写这边文章之前，我弄错了一点。看看下面的代码片段：<br><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>给出以下 JS，如果我点击 <code>div.inner</code>，打印的结果是什么？<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Let's get hold of those elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.outer'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> inner = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.inner'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Let;s listen for attribute changes on the</span></span><br><span class=\"line\"><span class=\"comment\">// outer element</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> MutationObserver(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'mutate'</span>);</span><br><span class=\"line\">&#125;).observe(outer, &#123;</span><br><span class=\"line\">  attributes: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Here's a click listener...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'click'</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  outer.setAttribute(<span class=\"string\">'data-random'</span>, <span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...which we'll attach to both elements</span></span><br><span class=\"line\">inner.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br><span class=\"line\">outer.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br></pre></td></tr></table></figure><br><br>在揭示答案之前可以用上述代码写个例子放到浏览器中测试——提示：打印会发生不止一次<br><br><br><br>#### 测试<br><br>点击内部的方块触发点击事件<br><br><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/3-square-click.html\" height=\"450\" width=\"600\" style=\"border: none;\"></iframe>\n\n<p>与你的猜测有出入？如果有出入，你仍有可能是对的，毕竟浏览器之间是有差异的：</p>\n<h4 id=\"到底谁是对的\"><a href=\"#到底谁是对的\" class=\"headerlink\" title=\"到底谁是对的\"></a>到底谁是对的</h4><p>派发 click 事件是一个任务；Mutation observer 以及 promise callbacks 会被编排为微任务；<code>setTimeout</code> 的回调会被编排为一个任务——以下便是代码运行的详细步骤：</p>\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/4-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>\n\n<p>Chrome 里运行的结果是正确的。对我来说比较“新”的一点是微任务会在回调之后处理（只要没有其他 JavaScript 在执行中），我认为它是限于任务的末尾——这一规则来源于 HTML 规范中调用回调：</p>\n<blockquote>\n<p>If the <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects\" target=\"_blank\" rel=\"noopener\">stack of script settings objects</a> is now empty, <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" rel=\"noopener\">perform a microtask checkpoint</a></p>\n<p>– <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback\" target=\"_blank\" rel=\"noopener\">HTML: Cleaning up after a callback</a> step 3 </p>\n</blockquote>\n<p>并且微任务检查点涉及遍历微任务队列，除非我们已经在处理微任务队列。类似的，ECMAScript 是这样描述作业的：</p>\n<blockquote>\n<p>仅当不存在正在运行的执行上下文，并且执行上下文的栈是空时，作业的执行<strong>可以</strong>被初始化</p>\n<p>—— ECMAScript: Jobs and Job Queues</p>\n</blockquote>\n<p>尽管 ECMAScript 中作业的“可以”变成了 HTML 上下文中的“必须”</p>\n<h4 id=\"浏览器出了什么问题？\"><a href=\"#浏览器出了什么问题？\" class=\"headerlink\" title=\"浏览器出了什么问题？\"></a>浏览器出了什么问题？</h4><p>正如 mutation callbacks 所示，<strong>Firefox</strong> 和 <strong>Safari</strong> 能够正常处理点击监听之间的微任务队列，但对 promise 的编排却有不同。这是可以理解的，毕竟作业与微任务之间的联系是模糊的，但我仍然希望他们能在 listener callbacks 之间执行。<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1193394\" target=\"_blank\" rel=\"noopener\">Firefox ticket</a>、<a href=\"https://bugs.webkit.org/show_bug.cgi?id=147933\" target=\"_blank\" rel=\"noopener\">Safari ticket</a></p>\n<p>至于 <strong>Edge</strong>，我们观察到它不仅不能正常编排 promise，也无法正常的处理点击监听之间的微任务队列，反而在调用所有监听器过后很久才会去处理微任务队列，因此表现为在两次click打印之后才记录到单个的mutate log。<a href=\"https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners\" target=\"_blank\" rel=\"noopener\">Bug ticket</a></p>\n<h4 id=\"第一关升级版\"><a href=\"#第一关升级版\" class=\"headerlink\" title=\"第一关升级版\"></a>第一关升级版</h4><p>同样的例子，如果我们执行下面这段代码，会发生什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inner.click();</span><br></pre></td></tr></table></figure>\n<p>这会像先前那样开始事件派发，但不是通过现实的交互而是脚本触发</p>\n<h4 id=\"小试牛刀-1\"><a href=\"#小试牛刀-1\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h4><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/5-click-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe>\n\n<p>各个浏览器的结果：</p>\n<p>我坚信我会在 Chrome 一直获取不同的结果，这张图我已经更新过无数次，我曾一度以为我错误的测试了 Canary（Chrome开发版）</p>\n<h4 id=\"为什么Chrome的结果会不确定\"><a href=\"#为什么Chrome的结果会不确定\" class=\"headerlink\" title=\"为什么Chrome的结果会不确定\"></a>为什么Chrome的结果会不确定</h4><p>请看执行的步骤：</p>\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/6-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>当我告诉我的同事 <a href=\"https://twitter.com/gauntface\" target=\"_blank\" rel=\"noopener\">Matt Gaunt</a> 我正打算写一篇关于 microtask 组织队列以及在浏览器事件循环中运行的文章时，他说“老实讲，Jake，打死我都不看”。好吧，不管怎样，文章嘛，写都写了╮(╯_╰)╭</p>\n<p>实际上，如果你倾向于看视频，<a href=\"https://twitter.com/philip_roberts\" target=\"_blank\" rel=\"noopener\">Philip Roberts</a> 在 JSConf 上关于 event loop 的<a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\" target=\"_blank\" rel=\"noopener\">演讲</a>会是不错的选择——虽然没有提到 microtask，但是其余部分还是挺出彩的</p>\n</blockquote>\n<p>看看这段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br></pre></td></tr></table></figure>\n<p>你觉得结果的打印顺序是什么？</p>\n<h4 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h4><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/1-log-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe><br>正确答案是：<br><br><code>script start</code>、<code>script end</code>、<code>promise1</code>、<code>promise2</code>、<code>setTimeout</code><br><br>但就浏览器的支持来说，有些浏览器上打印的结果却有出入（备注：原文写于2015年）<br><br>Microsoft Edge、Firefox 40、iOS Safari 以及 桌面版 Safari 8.0.0 会在 <code>promise1</code> 和 <code>promise2</code> 前打印 <code>setTimeout</code>，尽管看起来像是一种罕见的情况（备注：原文为 a race condition 个人认为应该是 rare condition）。很奇怪，因为 Firefox 39 和 Safari 8.0.7 打印的结果是正常的<br><br><br><br>#### 结果为什么会这样<br><br>要想明白其中的原理，你需要搞清楚 event loop 是如何处理 task 和 microtask<br><br>&gt; 每一个“线程”都有自己的 <strong>event loop</strong> ，同样，每一个 web worker 也都有自己的 event loop，它们能独立运行，但同时，同源下的所有窗口共享一个 event loop 以便能够同步的交流。Event loop 不停地运行，执行队列里的每一个 task。一个 event loop 会有多个 task source(任务源)，以此保证每个源下的 task 的执行顺序（例如 <a href=\"https://w3c.github.io/IndexedDB/#database-access-task-source\" target=\"_blank\" rel=\"noopener\">IndexedDB</a> 定义了自己的源），但浏览器会在每一轮循环里挑选源来获取要执行的 task。这使得浏览器能够给那些性能敏感（performance sensitive）的 task 给予优先权，例如 用户输入<br><br>&gt; 任务（task）会被编排（schedule）好，以便浏览器可以从其内部进入 JavaScript/DOM 领域并保证这些操作按顺序发生。从获取鼠标的单击事件到事件回调需要编排一个 task，同样的还有解析 HTML 以及上面提到的例子—— <code>setTimeout</code><br><br><code>setTimeout</code> 会在给定的延迟内等待，然后给它自己的回调编排一个新的 task ——这就是为什么 <code>setTimeout</code> 会在 <code>script end</code> 后面打印了—— <code>script end</code> 是第一个 task 的一部分，而 <code>setTimeout</code> 是在另一个隔离的 task 内打印的。<br><br>&gt; 微任务（microtask）通常被编排用于那些在当前正在执行的脚本后直接发生的事物，例如对一组批量操作作出反应，或者不需要通过创建一个额外的、完整的任务（task）来获取异步的结果。只要没有其他 JavaScript 处于执行中期，并且处于每个任务（task）的末尾时，微任务队列（microtask queue）就会在回调后处理。在微任务队列中任何编排的其他微任务都会被添加到队列的末尾并进行处理。微任务包括 mutation observer callbacks 以及上面例子中的 promise callback<br><br>一个 promise 实例的状态一旦变为凝滞，或者已经处于凝滞，它就会为其反应的回调向微任务队列中添加一个微任务——如此可以保证即使 promise 的状态已经凝滞，promise callback 一定是异步的。<br><br>因此调用一个紧挨着状态凝滞的 promise 的 <code>then(yey, nay)</code> 会立即编排一个微任务——这就是 <code>promise1</code> 和 <code>promise2</code> 会在 <code>script end</code> 之后打印的原因——当前运行的脚本一定会在微任务执行前结束；而 <code>promise1</code> 和 <code>promise2</code> 出现在 <code>setTimeout</code> 之前，是因为（当前任务的）微任务总是发生在下一个任务之前。<br><br><br><br>好吧，一步一步来：<br><br><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/2-step-test.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe><br>##### 为什么部分浏览器执行的结果会有差异<br><br>部分浏览器打印的结果是：<code>script start</code>、<code>script end</code>、<code>setTimeout</code>、<code>promise1</code>、<code>promise2</code>，从结果来看，它们会在 <code>setTimeout</code> 后面执行 promise 的回调——很有可能是因为它们将调用 promise 的回调当做新任务的一部分而不是微任务。<br><br>这是可以理解的，因为 promise 来源于 ECMAScript 而不是 HTML:)<br><br>ECMAScript 中有“作业（job）”的概念，这类似于微任务，但除了 <a href=\"https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16\" target=\"_blank\" rel=\"noopener\">vague mailing list duscussions</a> ，这两个概念的区别不是很明确。但普遍的共识是：有充足的理由要求我们将 promise 当做微任务队列的一部分<br><br>将 promise 视为任务会导致性能问题，因为其回调可能会因与渲染等与任务相关的事务而不必要的延迟，它还会因与其他任务源的交互而导致非确定性，并且可能会破坏与其他 API 的交互，后面会对这个展开叙述<br><br><a href=\"https://connect.microsoft.com/IE/feedback/details/1658365\" target=\"_blank\" rel=\"noopener\">Edge正尝试在 promise 中使用 microtask</a> （2015版 Edge，现在的 Edge 是基于 chrome 内核的），webkit nightly 一直都是这么做的，Firefox 43 也已经修复了这一点，所以我猜 Safari 最终也会选择修复这点<br><br><br><br>#### 如何判断用的是 task 还是 microtask<br><br>测试是一种方法。see when logs appear relative to promises &amp; setTimeout，尽管你依赖于正确的实现（代码实现正确为前提，观察打印的结果，剖析 promise 以及 setTimeout 表现出的关系）<br><br>查看规范也是一种方法。比如说，<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps\" target=\"_blank\" rel=\"noopener\"><code>setTimeout</code> 的第14步</a> 会编排一个任务，而 <a href=\"https://dom.spec.whatwg.org/#queue-a-mutation-record\" target=\"_blank\" rel=\"noopener\">queue a mutation record 的第5步</a> 会编排一个微任务<br><br>如上所述，在 ECMAScript 领域，microtask 被称为“作业（job）”。在 <a href=\"https://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen\" target=\"_blank\" rel=\"noopener\">PerformPromiseThen 的第8步</a> 中，<code>EnqueueJob</code> 会被调用去编排一个微任务<br><br><br><br>好吧，试试更复杂的例子吧<br><br>#### 第一关<br><br>在写这边文章之前，我弄错了一点。看看下面的代码片段：<br><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>给出以下 JS，如果我点击 <code>div.inner</code>，打印的结果是什么？<br><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Let's get hold of those elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.outer'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> inner = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.inner'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Let;s listen for attribute changes on the</span></span><br><span class=\"line\"><span class=\"comment\">// outer element</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> MutationObserver(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'mutate'</span>);</span><br><span class=\"line\">&#125;).observe(outer, &#123;</span><br><span class=\"line\">  attributes: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Here's a click listener...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'click'</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  outer.setAttribute(<span class=\"string\">'data-random'</span>, <span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...which we'll attach to both elements</span></span><br><span class=\"line\">inner.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br><span class=\"line\">outer.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br></pre></td></tr></table></figure><br><br>在揭示答案之前可以用上述代码写个例子放到浏览器中测试——提示：打印会发生不止一次<br><br><br><br>#### 测试<br><br>点击内部的方块触发点击事件<br><br><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/3-square-click.html\" height=\"450\" width=\"600\" style=\"border: none;\"></iframe>\n\n<p>与你的猜测有出入？如果有出入，你仍有可能是对的，毕竟浏览器之间是有差异的：</p>\n<h4 id=\"到底谁是对的\"><a href=\"#到底谁是对的\" class=\"headerlink\" title=\"到底谁是对的\"></a>到底谁是对的</h4><p>派发 click 事件是一个任务；Mutation observer 以及 promise callbacks 会被编排为微任务；<code>setTimeout</code> 的回调会被编排为一个任务——以下便是代码运行的详细步骤：</p>\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/4-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>\n\n<p>Chrome 里运行的结果是正确的。对我来说比较“新”的一点是微任务会在回调之后处理（只要没有其他 JavaScript 在执行中），我认为它是限于任务的末尾——这一规则来源于 HTML 规范中调用回调：</p>\n<blockquote>\n<p>If the <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects\" target=\"_blank\" rel=\"noopener\">stack of script settings objects</a> is now empty, <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\" rel=\"noopener\">perform a microtask checkpoint</a></p>\n<p>– <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback\" target=\"_blank\" rel=\"noopener\">HTML: Cleaning up after a callback</a> step 3 </p>\n</blockquote>\n<p>并且微任务检查点涉及遍历微任务队列，除非我们已经在处理微任务队列。类似的，ECMAScript 是这样描述作业的：</p>\n<blockquote>\n<p>仅当不存在正在运行的执行上下文，并且执行上下文的栈是空时，作业的执行<strong>可以</strong>被初始化</p>\n<p>—— ECMAScript: Jobs and Job Queues</p>\n</blockquote>\n<p>尽管 ECMAScript 中作业的“可以”变成了 HTML 上下文中的“必须”</p>\n<h4 id=\"浏览器出了什么问题？\"><a href=\"#浏览器出了什么问题？\" class=\"headerlink\" title=\"浏览器出了什么问题？\"></a>浏览器出了什么问题？</h4><p>正如 mutation callbacks 所示，<strong>Firefox</strong> 和 <strong>Safari</strong> 能够正常处理点击监听之间的微任务队列，但对 promise 的编排却有不同。这是可以理解的，毕竟作业与微任务之间的联系是模糊的，但我仍然希望他们能在 listener callbacks 之间执行。<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1193394\" target=\"_blank\" rel=\"noopener\">Firefox ticket</a>、<a href=\"https://bugs.webkit.org/show_bug.cgi?id=147933\" target=\"_blank\" rel=\"noopener\">Safari ticket</a></p>\n<p>至于 <strong>Edge</strong>，我们观察到它不仅不能正常编排 promise，也无法正常的处理点击监听之间的微任务队列，反而在调用所有监听器过后很久才会去处理微任务队列，因此表现为在两次click打印之后才记录到单个的mutate log。<a href=\"https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners\" target=\"_blank\" rel=\"noopener\">Bug ticket</a></p>\n<h4 id=\"第一关升级版\"><a href=\"#第一关升级版\" class=\"headerlink\" title=\"第一关升级版\"></a>第一关升级版</h4><p>同样的例子，如果我们执行下面这段代码，会发生什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inner.click();</span><br></pre></td></tr></table></figure>\n<p>这会像先前那样开始事件派发，但不是通过现实的交互而是脚本触发</p>\n<h4 id=\"小试牛刀-1\"><a href=\"#小试牛刀-1\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h4><iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/5-click-test.html\" height=\"300\" width=\"600\" style=\"border: none;\"></iframe>\n\n<p>各个浏览器的结果：</p>\n<p>我坚信我会在 Chrome 一直获取不同的结果，这张图我已经更新过无数次，我曾一度以为我错误的测试了 Canary（Chrome开发版）</p>\n<h4 id=\"为什么Chrome的结果会不确定\"><a href=\"#为什么Chrome的结果会不确定\" class=\"headerlink\" title=\"为什么Chrome的结果会不确定\"></a>为什么Chrome的结果会不确定</h4><p>请看执行的步骤：</p>\n<iframe src=\"https://cinyearchan.cn/task-microtask-demo/page/6-step-mutation.html\" height=\"550\" width=\"600\" style=\"border: none;\"></iframe>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}